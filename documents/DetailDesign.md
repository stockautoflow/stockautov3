# 株自動トレードシステム 詳細設計書 (v3.0)

## 1. 概要

### 1.1. システムの目的

本システムは、**Backtrader**による堅牢なバックテスト機能と、**Flask + Plotly**によるインタラクティブな分析UIを組み合わせ、取引戦略の検証と改善サイクルを高速化することを目的とする。

### 1.2. アーキテクチャ

システムは、以下の3つの主要コンポーネントで構成される。

1.  **バックテストエンジン (`run_backtrader.py`, `btrader_strategy.py`)**: Backtraderを利用して取引戦略のパフォーマンスを計算し、結果をCSVレポートに出力する。
2.  **Webアプリケーションサーバー (`app.py`)**: Flaskをベースとし、ブラウザからのリクエストに応じてチャート生成モジュールを呼び出し、結果を動的に表示するWebページを提供する。
3.  **チャート生成モジュール (`chart_generator.py`)**: `app.py`からライブラリとして呼び出され、価格データとインジケーターパラメータに基づき、PlotlyのグラフオブジェクトをJSON形式で生成する。

## 2. 環境構築手順

1.  **プロジェクトファイルの配置**: 全ファイルを単一のディレクトリに配置する。
2.  **仮想環境の構築**:
    ```bash
    python -m venv venv
    .\venv\Scripts\activate
    ```
3.  **ライブラリのインストール**:
    ```bash
    pip install -r requirements.txt
    ```

## 3. スクリプトの使用方法

1.  **バックテストの実行（取引履歴の更新が必要な場合）**:
    ```bash
    python run_backtrader.py
    ```
2.  **Web分析ツールの起動**:
    ```bash
    python app.py
    ```
3.  **ブラウザでアクセス**:
    * Webブラウザで `http://127.0.0.1:5001` を開く。

## 4. モジュール別詳細仕様

### 4.1. `requirements.txt`

* **役割**: プロジェクトの実行に必要なPythonライブラリとそのバージョンを定義する。
* **主要な内容**:
    * `backtrader`: バックテストのコアエンジン。
    * `pandas`, `numpy`: データ分析と数値計算。
    * `PyYAML`: 設定ファイルの読み込み。
    * `plotly`: インタラクティブチャートのデータ生成。
    * `Flask`: Webアプリケーションサーバー機能。

### 4.2. `config_backtrader.py`

* **役割**: システム全体で共有される静的な設定値を管理する。
* **主要な内容**:
    * **ディレクトリパス**: `DATA_DIR`, `RESULTS_DIR`, `LOG_DIR`, `REPORT_DIR`, `CHART_DIR`を定義。
    * **バックテスト共通設定**: `INITIAL_CAPITAL`（初期資金）、`COMMISSION_PERC`（手数料率）、`SLIPPAGE_PERC`（スリッページ率）などを定義。
    * **ロギング設定**: `LOG_LEVEL`でログの詳細度（`INFO`または`DEBUG`）を制御する。

### 4.3. `strategy.yml`

* **役割**: 取引戦略の**デフォルトパラメータ**を人間が編集しやすい形式で管理する。コードを変更せずに戦略の挙動を調整できる。
* **主要な内容**:
    * `trading_mode`: `long_enabled`と`short_enabled`のブール値で、ロング戦略とショート戦略の有効/無効を個別に切り替える。
    * `timeframes`: 長期・中期・短期の時間足と圧縮率を定義。
    * `indicators`: 各テクニカル指標（EMA, RSI, MACD, Stochastic, Bollinger Bands）のデフォルト期間や設定値を定義。
    * `filters`: エントリー条件で使用するフィルターの閾値を設定。
    * `exit_rules`: 損切り・利確のATR倍率を設定。
    * `sizing`: ポジションサイズ計算に用いるリスク割合を設定。

### 4.4. `email_config.yml`

* **役割**: メール送信に関する機密情報（ID、パスワード等）をコード本体から分離し、セキュリティを確保する。
* **主要な内容**:
    * `ENABLED`: メール通知機能の有効/無効を切り替えるフラグ。
    * `SMTP_SERVER`, `SMTP_PORT`: 送信に使用するメールサーバーの情報。
    * `SMTP_USER`, `SMTP_PASSWORD`: 認証情報。
    * `RECIPIENT_EMAIL`: 通知を受け取るメールアドレス。

### 4.5. `logger_setup.py`

* **役割**: Python標準の`logging`モジュールを設定し、一元的なログ管理機能を提供する。
* **主要な内容**: `setup_logging()`
    * 実行時のタイムスタンプに基づき、`log/backtest_YYYY-MM-DD-HHMMSS.log`というユニークなファイル名を生成する。
    * ログのフォーマットを「時間 - レベル - モジュール名 - メッセージ」に統一する。
    * ログの出力先を、コンソール（画面）と上記ログファイルの両方に設定する。

### 4.6. `notifier.py`

* **役割**: メール通知機能の実装。
* **主要な内容**: `send_email(subject, body)`
    * `email_config.yml`を読み込み、通知が有効になっているか確認する。
    * 有効な場合、Python標準の`smtplib`を使い、設定情報に基づいてメールを作成し送信する。

### 4.7. `btrader_strategy.py`

* **役割**: `Backtrader.Strategy`を継承し、取引戦略のコアロジックを実装する。
* **主要な内容**:
    * **`__init__(self)`**:
        * `strategy.yml`を読み込み、パラメータをインスタンス変数に保持する。
        * `self.datas`から各時間足のデータフィードへの参照を作成する。
        * `strategy.yml`のパラメータを基に、必要なテクニカル指標（EMA, RSI, ATR, MACD, Stochasticなど）をすべてインスタンス化する。
        * 取引ごとの情報を保持するためのインスタンス変数（`self.order`, `self.sl_price`, `self.tp_price`など）を初期化する。
    * **`next(self)`**:
        * 毎ローソク足ごとに呼び出されるメインロジック。
        * `strategy.yml`の`trading_mode`設定に従い、ロング戦略とショート戦略のロジックを条件分岐させる。
        * **ロング条件**: 長期EMAが上向き、かつ短期EMAがゴールデンクロスした場合に`buy_bracket()`でOCO注文を発注する。
        * **ショート条件**: 長期EMAが下向き、かつ短期EMAがデッドクロスした場合に`sell_bracket()`でOCO注文を発注する。
        * 注文前に、ATRベースで計算した損切り価格と利確価格をインスタンス変数（`self.sl_price`, `self.tp_price`）に保存する。
    * **`notify_trade(self, trade)`**:
        * 取引の開始と終了を検知する。取引開始時にロットサイズを`self.trade_size`に保存し、後のアナライザーでの計算に備える。
        * 取引決済時には損益をログに出力する。

### 4.8. `report_generator.py`

* **役割**: 複数のバックテスト結果を集約し、人間が読みやすい形式の総合サマリーレポートを生成する。
* **主要な内容**: `generate_report(...)`
    * 全銘柄のraw_statsリストと`strategy.yml`のパラメータを受け取る。
    * 純利益、勝率、プロフィットファクターなどのパフォーマンス指標を**全体で合算・再計算**する。
    * 計算結果に基づき、「総損益」「勝率」などに対する定性的な評価コメントを生成する。
    * `strategy.yml`の`trading_mode`設定を読み取り、レポートに記載する戦略の説明文（「Long Only」「Short Only」「Long/Short」など）を動的に生成する。
    * これら全ての情報を整形し、最終的なpandas.DataFrameとして返す。

### 4.9. `run_backtrader.py`

* **役割**: バックテスト全体の実行を管理し、レポートファイル（CSV）を出力する。
* **主要な内容**:
    * **`TradeList(bt.Analyzer)`**: 取引履歴を詳細に記録するためのカスタムアナライザー。
        * 取引開始時に、取引サイズ、エントリー根拠、損切り・利確価格、インジケーターの値を辞書に一時保存する。
        * 取引決済時に、一時保存した情報と決済時の情報（損益など）を組み合わせて、1行の取引記録を作成する。
        * 決済価格は、エントリー価格と損益（pnl）、保存しておいた取引サイズから正確に逆算する。
    * **`run_backtest_for_symbol(...)`**:
        * pandasでCSVファイルを`utf-8-sig`エンコーディングで読み込む。
        * Cerebroエンジンを初期化し、`stdstats=False`で標準のプロットを無効化する。
        * PandasDataフィードとしてデータを追加し、`resampledata`で他の時間足を生成する。
        * ブローカー設定（初期資金、手数料、スリッページ）を行う。
        * `cerebro.run()`でバックテストを実行し、アナライザーから数値結果と取引リストを抽出して返す。
    * **`main()`**:
        * 全必須ディレクトリの存在を確認・作成する。
        * `data`ディレクトリ内の全CSVファイルに対して`run_backtest_for_symbol`をループ実行し、結果をリストに集約する。
        * `report_generator`を呼び出して総合サマリーレポートを作成・保存する。
        * 集計したデータから、銘柄別詳細レポートと統合取引履歴レポートをそれぞれ作成・保存する。

### 4.10. `app.py` (Webアプリケーションサーバー)

* **役割**: Flaskサーバーを起動し、フロントエンドとバックエンドの橋渡しを行う。
* **主要なエンドポイント**:
    * `@app.route('/')`: メインページ (`index.html`) を描画する。利用可能な全銘柄リストと、`strategy.yml`から読み込んだインジケーターのデフォルト値をテンプレートに渡す。
    * `@app.route('/get_chart_data')`:
        * ブラウザ（JavaScript）からの非同期リクエストを受け付けるAPI。
        * リクエストのクエリパラメータ（銘柄、時間足、全インジケーターのパラメータ）を取得する。
        * 取得したパラメータを `chart_generator.generate_chart_json()` に渡し、チャートのJSONデータを生成させる。
        * `chart_generator.get_trades_for_symbol()` を呼び出し、該当銘柄の取引履歴を取得する。
        * チャートデータと取引履歴データをまとめてJSON形式でブラウザに返す。
* **起動処理**:
    * サーバー起動時に `chart_generator.load_data()` を一度だけ呼び出し、価格データと取引履歴をメモリにキャッシュする。これにより、リクエストごとのファイル読み込みをなくし、応答性を向上させる。

### 4.11. `templates/index.html` (フロントエンドUI)

* **役割**: ユーザーインターフェースの構造を定義し、チャートの動的更新ロジックを実装する。
* **主要なコンポーネント**:
    * **コントロールパネル**: 銘柄と時間足を選択するドロップダウンリストと、各インジケーターのパラメータを変更するための数値入力フォーム。
    * **チャート表示領域**: Plotlyのグラフが描画される `<div>` タグ。
    * **取引履歴テーブル**: チャートの下部に配置され、選択された銘柄の全取引履歴を表示する。
* **主要なJavaScriptロジック**:
    * **`updateChart()`**: コントロールパネルの全フォーム値を取得し、`/get_chart_data` APIに`fetch`リクエストを送信。返されたJSONでチャートとテーブルを更新する。
    * **`buildTradeTable()`**: 取引履歴データからテーブルの行を生成し、各行にクリックイベントを設定する。
    * **`highlightTradeOnChart()`**: テーブル行のクリックに連動し、チャート上の取引期間を半透明の矩形でハイライトする。
    * **イベントリスナー**: フォーム変更時やページ読み込み完了時に`updateChart()`を呼び出す。

### 4.12. `chart_generator.py` (チャート生成モジュール)

* **役割**: `app.py`から呼び出されるライブラリとして、Plotlyのグラフオブジェクトを生成する。
* **主要な関数**:
    * **`load_data()`**: アプリケーション起動時に一度だけ呼ばれ、必要なCSVデータをグローバル変数のキャッシュに読み込む。
    * **`generate_chart_json(symbol, timeframe, indicator_params)`**:
        * キャッシュから価格データを取得。
        * `indicator_params`に基づき、各種テクニカル指標を動的に計算。
        * `make_subplots`で、価格チャートと各指標用のサブプロットを動的に作成。
        * `go.Candlestick`, `go.Bar`, `go.Scatter`などを使い、フィギュアを構築する。
        * **`hovermode`を`'x unified'`に設定**し、Plotly標準の統一ツールチップを有効化する。
        * フィギュアオブジェクトをJSON形式の文字列に変換して返す。
    * **`get_trades_for_symbol(symbol)`**: キャッシュから指定された銘柄の取引履歴データを抽出して返す。
