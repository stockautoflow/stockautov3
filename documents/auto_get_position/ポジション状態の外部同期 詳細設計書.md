はい、承知いたしました。「ポジション状態の外部同期仕様書」に基づき、実装を目的とした詳細設計書を作成します。

---

### **ポジション状態の外部同期 詳細設計書**

#### **1\. 概要**

本設計書は、システムの内部ポジション状態をExcelファイルと同期させる機能の実装詳細を定義する。ExcelBridgeがExcelから実ポジションを読み取り、RealtimeTraderがその情報を用いて内部状態との差異を検出し、不整合がある場合は対象銘柄の取引スレッドを再起動することで状態をリセットする。

---

#### **2\. src/realtrade/bridge/excel\_bridge.py の改修**

##### **2.1. クラス設計**

ExcelBridgeクラスに、保有ポジションを保持するheld\_positions属性と、それを取得するget\_held\_positionsメソッドを追加する。

Python

import xlwings as xw  
import threading  
import time  
import logging  
import pythoncom

logger \= logging.getLogger(\_\_name\_\_)

class ExcelBridge:  
    def \_\_init\_\_(self, workbook\_path: str):  
        self.workbook\_path \= workbook\_path  
        self.latest\_data \= {}  
        self.held\_positions \= set()  \# \<\<\< 変更点: 保有ポジションを保持するセットを追加  
        self.lock \= threading.Lock()  
        self.is\_running \= False  
        self.data\_thread \= None

    def start(self):  
        \# ... (変更なし) ...

    def stop(self):  
        \# ... (変更なし) ...

    def \_data\_loop(self):  
        pythoncom.CoInitialize()  
        \# ... (既存のExcel接続処理) ...  
        try:  
            book \= xw.Book(self.workbook\_path)  
            data\_sheet \= book.sheets\['リアルタイムデータ'\]  
            position\_sheet \= book.sheets\['position'\] \# \<\<\< 変更点: positionシートを取得  
            logger.info("データ監視スレッドがExcelへの接続を確立しました。")  
        except Exception as e:  
            logger.critical(f"データ監視スレッドがExcelに接続できませんでした: {e}")  
            return

        while self.is\_running:  
            try:  
                \# ... (既存のリアルタイムデータ読み取り) ...

                \# \<\<\< 変更点: positionシートから保有銘柄リストを読み取る  
                positions\_list \= position\_sheet.range('A3:A102').value  
                current\_positions \= {str(int(p)) for p in positions\_list if p is not None and str(p).strip()}

                with self.lock:  
                    self.latest\_data\['account'\] \= {'cash': cash\_value}  
                    self.held\_positions \= current\_positions  
              
            except Exception as e:  
                \# ... (変更なし) ...  
              
            time.sleep(POLLING\_INTERVAL)  
        \# ... (変更なし) ...

    def get\_latest\_data(self, symbol: str) \-\> dict:  
        \# ... (変更なし) ...

    def get\_cash(self) \-\> float:  
        \# ... (変更なし) ...

    \# \<\<\< 変更点: 保有ポジションを取得するメソッドを新規追加  
    def get\_held\_positions(self) \-\> set:  
        with self.lock:  
            return self.held\_positions.copy()

    def place\_order(self, symbol, side, qty, order\_type, price):  
        \# ... (変更なし) ...

---

#### **3\. src/realtrade/run\_realtime.py の改修**

##### **3.1. クラス設計 (RealtimeTrader)**

RealtimeTraderクラスに、ポジション同期ループ(\_position\_sync\_loop)と取引スレッド再起動(\_reset\_cerebro\_threads)のメソッドを追加する。また、スレッド管理を容易にするため、リストではなく辞書(managed\_threads)で各銘柄のインスタンスを管理する。

##### **3.2. 修正後全文 (RealtimeTraderクラスのみ)**

Python

class RealtimeTrader:  
    def \_\_init\_\_(self):  
        logger.info("リアルタイムトレーダーを初期化中...")  
        self.strategy\_catalog \= self.\_load\_yaml(os.path.join(config.BASE\_DIR, 'config', 'strategy\_catalog.yml'))  
        self.base\_strategy\_params \= self.\_load\_yaml(os.path.join(config.BASE\_DIR, 'config', 'strategy\_base.yml'))  
        self.strategy\_assignments \= self.\_load\_strategy\_assignments(config.RECOMMEND\_FILE\_PATTERN)  
        self.symbols \= list(self.strategy\_assignments.keys())  
        self.state\_manager \= StateManager(os.path.join(config.BASE\_DIR, "results", "realtrade", "realtrade\_state.db"))  
          
        self.persisted\_positions \= self.state\_manager.load\_positions()  
        if self.persisted\_positions:  
            logger.info(f"DBから{len(self.persisted\_positions)}件の既存ポジションを検出しました。")

        \# \<\<\< 変更点: スレッド管理をリストから辞書に変更  
        self.managed\_threads \= {}  \# {symbol: {'thread': t, 'cerebro': c}}  
          
        self.bridge \= None  
        if config.LIVE\_TRADING and config.DATA\_SOURCE \== 'RAKUTEN':  
            if self.bridge is None:  
                logger.info("楽天証券(Excelハブ)モードで初期化します。")  
                self.bridge \= ExcelBridge(workbook\_path=config.EXCEL\_WORKBOOK\_PATH)  
                \# 注: bridge.start()は main() 関数から呼び出す想定

    \# ... (\_load\_yaml, \_load\_strategy\_assignments, \_run\_cerebro, \_create\_cerebro\_for\_symbol は変更なし) ...  
      
    def start(self):  
        logger.info("システムを開始します。")  
        if self.bridge:  
            self.bridge.start()  
              
        for symbol in self.symbols:  
            logger.info(f"--- 銘柄 {symbol} のセットアップを開始 \---")  
            cerebro\_instance \= self.\_create\_cerebro\_for\_symbol(symbol)  
            if cerebro\_instance:  
                t \= threading.Thread(target=self.\_run\_cerebro, args=(cerebro\_instance,), name=f"Cerebro-{symbol}")  
                \# \<\<\< 変更点: スレッド情報を辞書に格納  
                self.managed\_threads\[str(symbol)\] \= {'thread': t, 'cerebro': cerebro\_instance}  
                t.start()  
                logger.info(f"Cerebroスレッド (Cerebro-{symbol}) を開始しました。")  
          
        \# \<\<\< 変更点: ポジション同期ループを別スレッドで開始  
        self.sync\_thread \= threading.Thread(target=self.\_position\_sync\_loop, daemon=True)  
        self.sync\_thread.start()  
        logger.info("ポジション同期スレッドを開始しました。")

    def stop(self):  
        logger.info("システムを停止します。全データフィードに停止信号を送信...")  
        \# \<\<\< 変更点: 辞書を使ってスレッドを停止  
        for symbol, managed\_item in self.managed\_threads.items():  
            cerebro \= managed\_item\['cerebro'\]  
            if cerebro.datas and hasattr(cerebro.datas\[0\], 'stop'):  
                try:  
                    cerebro.datas\[0\].stop()  
                except Exception as e:  
                    logger.error(f"データフィードの停止中にエラー: {e}")  
          
        if self.bridge:  
            self.bridge.stop()

        logger.info("全Cerebroスレッドの終了を待機中...")  
        for symbol, managed\_item in self.managed\_threads.items():  
            managed\_item\['thread'\].join(timeout=10)  
          
        if self.state\_manager: self.state\_manager.close()  
        logger.info("システムが正常に停止しました。")

    \# \<\<\< 変更点: ポジション同期ループメソッドを新規追加  
    def \_position\_sync\_loop(self):  
        while True:  
            time.sleep(15) \# 15秒ごとにチェック  
            try:  
                if not self.bridge: continue  
                  
                real\_positions \= self.bridge.get\_held\_positions()  
                  
                \# managed\_threadsのコピーに対してループ処理  
                symbols\_to\_reset \= \[\]  
                for symbol, managed\_item in list(self.managed\_threads.items()):  
                    cerebro \= managed\_item\['cerebro'\]  
                      
                    \# cerebroインスタンスが有効か確認  
                    if not cerebro or not cerebro.datas: continue  
                          
                    position\_size \= cerebro.broker.getposition(cerebro.datas\[0\]).size  
                      
                    \# 内部的にポジションがあるのに、Excelのリストにない場合  
                    if position\_size \!= 0 and symbol not in real\_positions:  
                        logger.warning(f"\[{symbol}\] 内部ポジション({position\_size})とExcelの不整合を検出。リセットします。")  
                        symbols\_to\_reset.append(symbol)

                if symbols\_to\_reset:  
                    self.\_reset\_cerebro\_threads(symbols\_to\_reset)

            except Exception as e:  
                logger.error(f"ポジション同期ループでエラー: {e}", exc\_info=True)

    \# \<\<\< 変更点: スレッド再起動メソッドを新規追加  
    def \_reset\_cerebro\_threads(self, symbols: list):  
        for symbol in symbols:  
            \# 1\. 古いスレッドを停止・削除  
            managed\_item \= self.managed\_threads.pop(str(symbol), None)  
            if managed\_item and managed\_item\['thread'\].is\_alive():  
                managed\_item\['cerebro'\].datas\[0\].stop()  
                managed\_item\['thread'\].join(timeout=5)  
                logger.info(f"\[{symbol}\] 古いCerebroスレッドを停止しました。")  
              
            \# 2\. 新しいスレッドを生成・開始  
            logger.info(f"\[{symbol}\] 新しいCerebroスレッドを開始します。")  
            cerebro\_instance \= self.\_create\_cerebro\_for\_symbol(symbol)  
            if cerebro\_instance:  
                t \= threading.Thread(target=self.\_run\_cerebro, args=(cerebro\_instance,), name=f"Cerebro-{symbol}")  
                self.managed\_threads\[str(symbol)\] \= {'thread': t, 'cerebro': cerebro\_instance}  
                t.start()  
