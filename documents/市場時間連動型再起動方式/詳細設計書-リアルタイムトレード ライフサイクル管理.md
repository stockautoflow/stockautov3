承知いたしました。基本仕様書に基づき、**詳細設計書（Detailed Design Document）** を作成します。

この設計書では、`run_realtrade.py` を「24時間稼働の監視プロセス（スーパーバイザー）」へと変貌させ、`RealtimeTrader` インスタンスを適切に生成・破棄するための具体的なロジックと実装仕様を定義します。

-----

# 詳細設計書: リアルタイムトレード ライフサイクル管理

**プロジェクト:** StockAutoV3  
**作成日:** 2025/11/25  
**バージョン:** 1.0  
**実装ファイル:** `src/realtrade/run_realtrade.py`

## 1\. アーキテクチャ概要

### 1.1. スーパーバイザー・ワーカーモデル

本改修により、`run_realtrade.py` の役割を「トレード実行」から「トレードプロセスの管理（スーパーバイザー）」へ変更する。

  * **Main Loop (Supervisor):**
      * Pythonプロセスとして常駐（24時間稼働）。
      * 市場時間を監視し、`RealtimeTrader` の生存期間を制御する。
      * 例外処理の最終防壁となり、ログを記録する。
  * **RealtimeTrader (Worker):**
      * 市場稼働時間のみ存在するインスタンス。
      * 生成時 (`__init__`) にリソースを確保し、破棄時 (`stop`) に完全開放する。
      * 前日のメモリ状態を引き継がない「使い捨て」運用とする。

## 2\. モジュール設計 (`run_realtrade.py`)

### 2.1. 必要なインポートの追加

時間計算と制御のために、以下の標準ライブラリを追加インポートする。

```python
from datetime import datetime, time, timedelta
import threading # 既存
import time as time_module # 既存(time)との名前衝突回避のためリネーム推奨、あるいは from time import sleep 利用
```

### 2.2. 関数定義

#### `is_market_active(current_dt: datetime) -> bool`

現在時刻が、システムを稼働させるべき時間帯（アクティブウィンドウ）に含まれるかを判定する。

  * **入力:** 現在日時 (`datetime`)
  * **ロジック:**
    1.  **週末判定:** `current_dt.weekday()` が 5(土) または 6(日) なら `False` を返す。
    2.  **時間判定:**
          * 開始時刻: **09:00:00**
          * 終了時刻: **15:30:00** (データ遅延とクロージング処理を考慮)
    <!-- end list -->
      * ※ 昼休み（11:30～12:30）は、頻繁な再起動によるオーバーヘッドとリスクを避けるため、**「稼働中（True）」** とみなす。この間、データフィード側でTickは供給されないが、プロセスは維持する。
  * **出力:** `True` (稼働すべき) / `False` (停止すべき)

#### `get_seconds_until_next_open(current_dt: datetime) -> float`

次の市場開始時刻（起動すべき時刻）までの待機秒数を計算する。

  * **入力:** 現在日時 (`datetime`)
  * **ロジック:**
    1.  **基準開始時刻の設定:** `current_dt` の日付の **09:00:00** を基準とする。
    2.  **日付の調整:**
          * 現在時刻が既に 09:00 を過ぎている場合（かつ市場クローズ後の場合）、基準日を「翌日」に進める。
    3.  **週末スキップ:**
          * 基準日が土曜(5) または 日曜(6) の場合、月曜(0) になるまで日付を1日ずつ進める。
    4.  **秒数計算:** `(基準開始時刻 - current_dt).total_seconds()` を返す。
  * **出力:** 待機秒数 (`float`)

### 2.3. `main()` 関数フロー（ステートマシン）

メインループは以下の状態遷移を持つ。

| 状態 | 条件 | アクション | 遷移先 |
| :--- | :--- | :--- | :--- |
| **INIT** | プロセス起動時 | ロガー設定、通知機能開始 | **MONITOR** |
| **MONITOR** | ループ開始 | 現在時刻取得、`is_market_active` 判定 | **START** / **STOP** |
| **START** | `Active=True` かつ `trader is None` | `RealtimeTrader()` 生成、`.start()` 実行、ログ出力 | **MONITOR** |
| **STOP** | `Active=False` かつ `trader exists` | `trader.stop()` 実行、`trader = None`、ログ出力 | **WAIT** |
| **WAIT** | `Active=False` | 次回起動時刻を計算・ログ出力、`time.sleep()` (最大60秒刻み) | **MONITOR** |

#### 処理フロー詳細

1.  **初期化:**

      * ログ設定、メール通知機能(`notifier`)の開始。
      * 変数 `trader = None` で初期化。

2.  **監視ループ (`while True`):**

      * 現在時刻 `now` を取得。
      * **判定A: 市場稼働時間か？** (`is_market_active(now)`)
          * **YES (稼働時間):**
              * `trader` が `None` (未起動) ならば:
                  * [INFO] "市場オープン。トレーダーを起動します。"
                  * `trader = RealtimeTrader()`
                  * `trader.start()`
              * `trader` が存在するなら:
                  * 何もしない（稼働継続）。
                  * `time.sleep(1)` でCPU負荷を下げる。
          * **NO (時間外):**
              * `trader` が存在する (起動中) ならば:
                  * [INFO] "市場クローズ。トレーダーを停止します。"
                  * `trader.stop()`
                  * `trader = None` (参照を消去しGC対象にする)
              * **待機処理:**
                  * `wait_seconds = get_seconds_until_next_open(now)`
                  * [INFO] "次回起動まで待機: {時間}秒 ({日時})"
                  * `sleep_chunk = 60` (60秒ごとに割り込みチェック)
                  * ループで `time.sleep(min(wait_seconds, sleep_chunk))` を実行し、待機時間を消費する。
                  * ※ 待機中も `KeyboardInterrupt` を検知できるようにする。

3.  **終了処理 (`finally`):**

      * 例外発生時やループ脱出時。
      * `if trader: trader.stop()` (安全な停止)
      * `notifier.stop_notifier()`

## 3\. データ永続化と復元（既存機能の確認）

本設計は、以下の既存機能が正常に動作することを前提とする。

1.  **停止時 (Stop):**
      * `RealtimeTrader.stop()` -\> `RealTradeEventHandler` -\> `StateManager`
      * ポジション状態が SQLite (`realtrade_state.db`) にコミットされること。
2.  **起動時 (Start):**
      * `RealtimeTrader.__init__` -\> `CerebroFactory` -\> `RealTradeStrategy`
      * `RealTradeStrategy._setup_components` -\> `StateManager.load_positions()`
      * DBから読み込まれたポジションが `Strategy.position` に反映（復元）されること。

## 4\. エラーハンドリング設計

  * **KeyboardInterrupt (Ctrl+C):**
      * どの状態（稼働中、スリープ中）であっても、即座に `finally` ブロックへ移行し、`trader.stop()` を実行してプロセスを終了する。
  * **予期せぬ例外:**
      * `main` ループ全体を `try...except Exception` で囲む。
      * エラー発生時は [CRITICAL] ログを出力し、`trader.stop()` を試みた後、通知 (`notifier`) を送ってプロセスを終了する（無限再起動ループを防ぐため、一度終了させる方針とする）。

## 5\. テスト・検証シナリオ

実装後、以下のシナリオで動作を確認する。

| ID | シナリオ | 期待される動作 |
| :--- | :--- | :--- |
| **T1** | **市場時間外での起動** | `run_realtrade.py` 実行直後、トレーダーは起動せず、「次回起動時刻」を表示して待機モードに入ること。 |
| **T2** | **市場時間内での起動** | `run_realtrade.py` 実行直後、トレーダーが起動し、ログに接続開始のメッセージが出ること。 |
| **T3** | **時間経過による停止** | 稼働中に時刻設定を一時的に変更（またはコード内の判定時刻を変更）し、15:30をまたいだ瞬間に停止処理が走り、待機モードへ移行すること。 |
| **T4** | **時間経過による再起動** | 待機中に時刻設定を変更（またはコード変更）し、09:00をまたいだ瞬間に、トレーダーの初期化と起動が行われること。 |
| **T5** | **ポジション復元** | ポジションを持った状態で強制停止（T3）させ、再起動（T4）した際に、ポジションが維持されていること。 |

-----

以上が詳細設計となります。
ご確認いただき、問題がなければ **３，実装計画書の作成（MD形式）** へ進みます。