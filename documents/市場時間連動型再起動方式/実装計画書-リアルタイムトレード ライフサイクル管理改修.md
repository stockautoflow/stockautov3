承知いたしました。詳細設計書に基づき、**実装計画書（Implementation Plan）** を作成します。

-----

# 実装計画書: リアルタイムトレード ライフサイクル管理改修

**プロジェクト:** StockAutoV3  
**作成日:** 2025/11/25  
**バージョン:** 1.0  
**実装担当:** AIアシスタント & ユーザー  
**対象ファイル:** `src/realtrade/run_realtrade.py`

## 1\. 概要

`ValueError: min() iterable argument is empty` によるクラッシュを回避するため、`run_realtrade.py` を改修し、市場時間外にシステムを完全停止（再起動待機）させるロジックを実装する。

## 2\. 実装ステップ

### ステップ 1: 必要なモジュールのインポート追加

`run_realtrade.py` の冒頭に、時間計算とスリープ制御に必要なモジュールを追加する。

  * **追加:** `from datetime import datetime, time, timedelta`
  * **変更:** `import time` を `import time as time_module` に変更（または `time.sleep` の使用箇所を調整）し、`datetime.time` との競合を避ける。

### ステップ 2: 時間判定ロジックの実装

`main` 関数の外側（または内部）に、以下のヘルパー関数を実装する。

1.  **`is_market_active(now)`**:

      * 現在時刻を受け取り、市場稼働時間内（平日 09:00～15:30）かどうかを `True/False` で返す。
      * 週末（土日）は `False`。
      * 昼休み（11:30～12:30）は `True`（稼働維持）とする。

2.  **`get_seconds_until_next_open(now)`**:

      * 現在時刻から、次の「市場開始時刻（平日 09:00）」までの秒数を計算して返す。
      * 当日が金曜の夜なら、月曜の朝までの秒数を計算するロジックを含める。

### ステップ 3: `main()` 関数のループ構造の刷新

既存の `main()` 関数内の単純な `trader.start()` ロジックを、以下の **ステートマシン型ループ** に置き換える。

  * **ループ構造:** `while True:` で無限ループを作成。
  * **条件分岐:**
      * **CASE A: 市場稼働中 (`is_market_active` == True)**
          * `trader` が未作成 (`None`) なら → `RealtimeTrader()` を生成し `.start()`。
          * `trader` が既にあるなら → 何もしない（`time.sleep(1)`）。
      * **CASE B: 市場時間外 (`is_market_active` == False)**
          * `trader` が既にあるなら → `trader.stop()` を呼び出し、`trader = None` にする。
          * 次回起動までの時間を計算し、ログに出力する。
          * 待機ループに入る（60秒ごとに `Ctrl+C` をチェックしながらスリープ）。

### ステップ 4: 安全な終了処理の強化

`try...finally` ブロックを確認し、以下の終了処理が確実に呼ばれるようにする。

  * `if trader: trader.stop()`
  * `notifier.stop_notifier()`

## 3\. 生成されるコード (`tmp.py` 用)

以下のコードブロックは、`run_realtrade.py` の全量置き換えコードとして生成される予定である。

```python
import logging
import time as time_module  # リネームして競合回避
import yaml
import pandas as pd
import glob
import os
import sys
import threading
from datetime import datetime, time, timedelta # 追加

# --- Project Root Setup ---
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
if project_root not in sys.path:
    sys.path.append(project_root)

# --- Local Imports ---
from src.core.util import logger as logger_setup, notifier
from . import config_realtrade as config
from .bridge.excel_connector import ExcelConnector
from .position_synchronizer import PositionSynchronizer
from .cerebro_factory import CerebroFactory

logger = logging.getLogger(__name__)

# ... (RealtimeTrader クラス定義は変更なし) ...

# --- Helper Functions ---
def is_market_active(now: datetime) -> bool:
    """
    現在時刻が市場稼働時間内（平日 09:00 - 15:30）かを判定する。
    昼休み中もプロセス維持のため True を返す。
    """
    if now.weekday() >= 5: # 土(5), 日(6)
        return False
    
    current_time = now.time()
    # 09:00 <= now <= 15:30
    start_time = time(9, 0)
    end_time = time(15, 30)
    
    return start_time <= current_time <= end_time

def get_seconds_until_next_open(now: datetime) -> float:
    """
    次の市場開始時刻（平日 09:00）までの秒数を計算する。
    """
    # 基準は今日の09:00
    next_open = now.replace(hour=9, minute=0, second=0, microsecond=0)
    
    # もし今日の09:00を過ぎていたら（つまり夕方なら）、明日の09:00にする
    if now >= next_open:
        next_open += timedelta(days=1)
    
    # 週末スキップ（土日なら月曜まで進める）
    while next_open.weekday() >= 5:
        next_open += timedelta(days=1)
        
    return (next_open - now).total_seconds()

def main():
    logger_setup.setup_logging(config.LOG_DIR, log_prefix='realtime', level=config.LOG_LEVEL)
    notifier.start_notifier()
    trader = None

    logger.info("=== StockAutoV3 Realtime Supervisor Started ===")

    try:
        while True:
            now = datetime.now()
            
            if is_market_active(now):
                # --- [A] 市場稼働時間 ---
                if trader is None:
                    logger.info(f"市場オープン ({now.strftime('%H:%M')})。トレーダーを起動します。")
                    trader = RealtimeTrader()
                    trader.start()
                else:
                    # 稼働中は負荷をかけないよう短くスリープ
                    time_module.sleep(1)
            else:
                # --- [B] 市場時間外 ---
                if trader is not None:
                    logger.info(f"市場クローズ ({now.strftime('%H:%M')})。トレーダーを停止・破棄します。")
                    trader.stop()
                    trader = None
                    logger.info("トレーダーの停止が完了しました。")

                # 次回起動までの待機処理
                wait_seconds = get_seconds_until_next_open(now)
                wait_hours = wait_seconds / 3600
                
                # ログは頻繁に出しすぎない（例えば1時間に1回や、ステータス変更時のみ）
                # ここでは簡易的に、待機に入る直前だけ出す
                logger.info(f"次回市場開始まで待機モードに入ります。({wait_hours:.1f}時間後)")
                
                # 長時間スリープを分割して、Ctrl+Cに反応できるようにする
                sleep_chunk = 60 # 60秒ごとにチェック
                while wait_seconds > 0:
                    sleep_time = min(wait_seconds, sleep_chunk)
                    time_module.sleep(sleep_time)
                    wait_seconds -= sleep_time
                    
                    # 待機中に日付が変わったり時間が経過するので、正確を期すなら
                    # ループ先頭に戻って is_market_active を再評価した方が安全だが、
                    # ここでは単純なスリープ消費とする。
                    # より堅牢にするため、この内側ループを抜け、外側の while True で再評価させる手もある。
                    # 今回は「再評価」を優先し、単純な break で外側ループに戻す。
                    break 

    except KeyboardInterrupt:
        logger.info("Ctrl+C detected. Shutting down gracefully.")
    except Exception as e:
        logger.critical(f"An unhandled exception occurred in the main thread: {e}", exc_info=True)
    finally:
        if trader:
            logger.info("Performing final cleanup...")
            trader.stop()
        notifier.stop_notifier()
        logger.info("Application has been shut down.")

if __name__ == '__main__':
    main()
```

## 4\. 検証計画

1.  **静的確認**: 生成されたコードに構文エラーがないか確認。
2.  **擬似時刻テスト**: `is_market_active` 内の `9, 0` や `15, 30` を現在の時刻付近に書き換え、起動・停止のサイクルが回るかを確認する（※ユーザー環境での手動テスト）。
3.  **強制停止テスト**: 待機モード中に `Ctrl+C` を押し、プロセスが正常終了するか確認する。

-----

以上が実装計画書となります。
ご確認いただき、問題がなければ **４，実装（tmp.pyの生成）** へ進みます。