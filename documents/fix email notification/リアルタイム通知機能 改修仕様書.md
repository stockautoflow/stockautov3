はい、承知いたしました。
これまでの議論で明らかになった設計経緯（5.1フラグと5.2時間差判定の関係性、5.1フラグの動作メカニズム）を「補足」として追記した、最終版の基本仕様書を作成します。

-----

# リアルタイム通知機能 改修仕様書 (v5)

## 1\. 概要

本改修は、`BarBuilder`（5分足バー生成ロジック）の導入に伴い、リアルタイムトレード実行時にメール通知が意図せず抑制される問題を解決することを目的とする。

## 2\. 背景と問題点

`BarBuilder` の導入により、ストラテジーが処理するバーのタイムスタンプ（バーの開始時刻）と、実際の処理時刻（バーの終了時刻）の間に、仕様として必ず5分以上の遅延が発生するようになった。

一方、現在の通知クラス `RealTradeStrategyNotifier` には、履歴データ再生中の誤通知を防ぐため、「バーの時刻と現在時刻の差が5分を超えたら通知を抑制する」ロジックが実装されている。

この2つの仕様が競合し、正常なリアルタイム通知が「過去データ」と誤判定され、すべてブロックされてしまっている。

## 3\. 改修方針

通知クラス `RealTradeStrategyNotifier` が、以下の2つの責務を正しく実行できるように修正する。

1.  **履歴データの抑制:** システム起動時の履歴データ再生に基づく通知は、`RealTradeStrategy` の `realtime_phase_started` フラグ を参照し、従来通り**抑制**する。
2.  **遅延の明記:** リアルタイムフェーズにおいて「異常な処理遅延」（例: 15分以上）を検知した場合、**通知を抑制せず**、件名および本文に**警告を追記**して通知する。これは「手動発注モード」 で動作しているユーザーに対し、判断材料（遅延の事実）をすべて提供するためである。

## 4\. 対象コンポーネント

  * **ファイル:** `src/realtrade/implementations/strategy_notifier.py`
  * **クラス:** `RealTradeStrategyNotifier`
  * **メソッド:** `send(self, subject, body, immediate=False)`

## 5\. 実装仕様

`send` メソッド内のロジックを、以下の流れに変更する。

1.  **5.1. 履歴データ再生中の判定（第一チェック）**

      * `getattr(self.strategy, 'realtime_phase_started', False)` が `False` の場合、「履歴データ再生中」とみなし、通知を `return` で抑制する。

2.  **5.2. 時間差判定（第二チェック）**

      * `bar_datetime`（バー時刻）と `datetime.now()`（現在時刻）の差（`time_diff`）を計算する。
      * 閾値（`allowed_delay = timedelta(minutes=15)`）を超えるか判定し、`is_delayed` フラグを設定する。

3.  **5.3. 警告の追記**

      * `is_delayed` が `True` の場合、**抑制（`return`）せず**、以下の処理を行う。
          * `subject`（件名）: 遅延分数と警告を追記する。決済通知（件名に "決済" や "Stop Loss" を含む）は、より目立つように `!!!` を付ける。
          * `body`（本文）: 遅延分数とバーの時刻を明記した警告文を、本文の先頭に追加する。

4.  **5.4. 通知の実行**

      * 警告が追記された、あるいは遅延していない通知を `notifier.send_email` で送信する。

## 6\. 修正後のコード（イメージ）

```python
# src/realtime/implementations/strategy_notifier.py (最終修正案)

import logging
from datetime import datetime, timedelta
from src.core.util import notifier
from src.core.strategy.strategy_notifier import BaseStrategyNotifier

class RealTradeStrategyNotifier(BaseStrategyNotifier):
    """
    [リファクタリング - 実装]
    実際に通知（メール送信など）を行う。
    履歴再生中は抑制し、リアルタイム中の異常遅延は警告を追記して通知する。
    """
    def __init__(self, strategy):
        super().__init__(strategy)
        self.logger = logging.getLogger(self.__class__.__name__)

    def send(self, subject, body, immediate=False):
        
        # 5.1. 履歴データ再生中の判定 (全通知に適用)
        #
        if not getattr(self.strategy, 'realtime_phase_started', False):
            self.logger.debug(f"履歴データ供給中のため通知を抑制: {subject}")
            return
        
        bar_datetime = self.strategy.data0.datetime.datetime(0)
        if bar_datetime.tzinfo is not None:
            bar_datetime = bar_datetime.replace(tzinfo=None)

        # 5.2. 時間差判定の準備
        allowed_delay = timedelta(minutes=15)
        time_diff = datetime.now() - bar_datetime
        is_delayed = time_diff > allowed_delay

        # 5.3. 警告の追記
        if is_delayed:
            delay_minutes = int(time_diff.total_seconds() / 60)
            
            # 決済通知 (件名に "決済" や "Stop Loss" を含む) かどうかで警告レベルを変更
            if "決済" in subject or "Stop Loss" in subject:
                subject = f"【!!!決済遅延警告: {delay_minutes}分前!!!】{subject}"
            else:
                subject = f"【エントリー遅延警告: {delay_minutes}分前】{subject}"
            
            warning_msg = (
                f"警告: このシグナルは {delay_minutes}分前 ({bar_datetime.isoformat()}) のデータに基づいています。\n"
                f"現在の価格と乖離している可能性があります。\n"
                f"------------------------------------\n\n"
            )
            body = warning_msg + body
        
        # 5.4. 通知の実行
        self.logger.debug(f"通知リクエストを発行: {subject}")
        #
        notifier.send_email(subject, body, immediate=immediate)

```

-----

## 7\. 補足：設計経緯の詳細

### 7.1. 5.2（時間差判定）ロジックが実装された経緯

今回の問題は、システムのリファクタリング（機能改善）プロセスにおける「更新漏れ」が根本原因である。

1.  **旧システムの仕様:**
    `BarBuilder` や `realtime_phase_started` フラグ が導入される**前**の旧システムでは、履歴データ再生中か否かを判定する専用のフラグが存在しなかった。
2.  **旧システムの判定方法:**
    そのため、「バーの時刻と現在時刻の時間差」を測定し、一定時間（例: 5分）を超えたら履歴データとみなす 5.2（時間差判定）ロジック が、唯一の判定手段として実装されていた。
3.  **今回の更新漏れ:**
    今回のリファクタリングで、より優れた 5.1（`realtime_phase_started` フラグ） が新設された。しかし、`RealTradeStrategyNotifier`（通知クラス） が、この新しい 5.1 フラグ を参照するよう更新されず、旧システムの 5.2（5分ルール）ロジック を使い続けてしまった。
4.  **問題の発生:**
    `BarBuilder` によって「正常なリアルタイム処理でも5分の遅延」が発生するようになったため、旧システムの 5.2（5分ルール）ロジック が、すべてのリアルタイム通知を誤ってブロックする結果となった。

### 7.2. 5.1（`realtime_phase_started` フラグ）の動作メカニズム

5.1 のフラグ判定は、データ供給側と戦略側の連携によって実現されている。

1.  **データ供給側（`RakutenData`）:**
    まず、CSVなどから読み込んだ過去の履歴データをすべて供給（再生）する。再生が完了すると、自身の内部フラグ `self.history_supplied` を `True` に設定する。
2.  **戦略側（`RealTradeStrategy`）:**
    `next` メソッド が実行されるたび、データ供給側の `history_supplied` フラグ を監視する。
3.  **移行の検知:**
    `history_supplied` が `True` になったことを検知した瞬間、`RealTradeStrategy` は「履歴データの再生が完了し、リアルタイムフェーズに移行した」と判断し、自身の `self.realtime_phase_started` フラグを `True` に切り替える。
4.  **通知側（`RealTradeStrategyNotifier`）:**
    本改修により、通知クラスはこの `realtime_phase_started` フラグ を参照し、`False` の間は通知を抑制する（5.1）。