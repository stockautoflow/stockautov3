はい、承知いたしました。
ご提供いただいた現状のコード一式を分析し、当初のご要件（パフォーマンス向上のためのログ機能改修）を達成するための基本仕様書を、改めて作成いたします。

前回ご提示した仕様書に、現状のコードとの乖離があった点、大変失礼いたしました。以下に、現状のコード構成を正しく踏まえた上での改修仕様を記述します。

-----

# バックテストログ機能改修 基本仕様書

## 1\. 概要

本仕様書は、株式自動トレードシステムのバックテスト機能におけるログ出力メカニズムの改修に関する仕様を定義する。主目的は、大規模な戦略評価（`evaluation`）実行時におけるパフォーマンスを、不要なログ出力を抑制することで向上させることである。

-----

## 2\. 現状の課題

  - **パフォーマンスのボトルネック**: `src/backtest/config_backtest.py`において、ログレベルが`logging.DEBUG`に固定されている。これにより、全銘柄を対象とする`evaluation`実行時に、膨大な量のデバッグログがコンソールおよびファイルに出力され、深刻なI/Oボトルネックと実行速度の低下を引き起こしている。
  - **柔軟性の欠如**: ログレベルを変更するには、`src/backtest/config_backtest.py`のコードを直接編集する必要がある。そのため、`evaluation`実行時のみログを抑制するといった、状況に応じた動的な制御ができない。

-----

## 3\. 設計方針

現状のアーキテクチャ（`evaluation`から`backtest`をサブプロセスとして呼び出す仕組み）を維持しつつ、以下の設計方針で課題を解決する。

  - **設定ファイルによる一元管理**: `evaluation`パッケージに専用の設定ファイル`config_evaluation.py`を新設し、ログレベル設定を集約する。
  - **動的な設定上書き**: `evaluation`の実行時、`orchestrator.py`が`backtest`を呼び出す直前に、`backtest`の設定ファイル(`src/backtest/config_backtest.py`)を**一時的に書き換える**。
  - **確実な状態復元**: `try...finally`構文を利用し、バックテスト処理の成否にかかわらず、書き換えた設定ファイルを**必ず元の状態に復元**することで、システムの整合性を保つ。
  - **ログ無効化モードの導入**: ログレベルとして特殊値`None`を許容するようコア・ロガーを改修し、ログ出力を完全に停止する手段を提供する。

-----

## 4\. 機能仕様詳細

### 4.1. `core`パッケージの改修

#### 4.1.1. `src/core/util/logger.py`

  - **目的**: ログ出力を完全に無効化する機能を追加する。
  - **改修内容**:
      - `setup_logging`関数が、引数`level`に`None`を受け取った場合、ログハンドラーを一切設定せずに関数を終了するように変更する。
      - 他のライブラリが出力する警告を抑制するため、`level`が`None`の場合は`logging.NullHandler`をルートロガーに追加する。

<!-- end list -->

```python
# src/core/util/logger.py
def setup_logging(log_dir, log_prefix, level=logging.INFO):
    if level is None:
        # ログが無効化されたことを示す
        logging.getLogger().addHandler(logging.NullHandler())
        return
    # (以降の処理は変更なし)
```

### 4.2. `backtest`パッケージの改修

#### 4.2.1. `src/backtest/config_backtest.py`

  - **目的**: バックテスト単体実行時のデフォルトのログレベルを定義する。
  - **改修内容**:
      - `LOG_LEVEL`の値を、デバッグに適した`logging.DEBUG`から、通常の実行に適した`logging.INFO`に変更する。
      - この設定が`evaluation`実行時に一時的に上書きされることをコメントで明記する。

<!-- end list -->

```python
# src/backtest/config_backtest.py

# --- ロギング設定 ---
# バックテスト単体実行時のデフォルトログレベル。
# evaluation実行時は、この値がconfig_evaluation.pyの設定で一時的に上書きされます。
LOG_LEVEL = logging.INFO # INFO or DEBUG or None
```

### 4.3. `evaluation`パッケージの改修

#### 4.3.1. `src/evaluation/config_evaluation.py` (新規作成)

  - **目的**: `evaluation`プロセスに関する設定（特にログレベル）を一元管理する。
  - **仕様**:
      - `LOG_LEVEL`: `evaluation`プロセス自体のログレベルを定義する (デフォルト: `logging.INFO`)。
      - `BACKTEST_LOG_LEVEL_OVERRIDE`: `evaluation`から呼び出す`backtest`プロセスのログレベルを上書き定義する。パフォーマンス向上のため、デフォルト値は `'NONE'` とする。

<!-- end list -->

```python
# src/evaluation/config_evaluation.py (新規ファイル)
import logging

# evaluationモジュール自体のログレベル
LOG_LEVEL = logging.INFO

# evaluationから呼び出すバックテストのログレベルを指定
# 'NONE' に設定するとログ出力を完全に抑制し、実行を高速化する
BACKTEST_LOG_LEVEL_OVERRIDE = 'NONE' # 'INFO', 'DEBUG', 'NONE' のいずれかを指定
```

#### 4.3.2. `src/evaluation/orchestrator.py`

  - **目的**: バックテスト実行時に、`config_backtest.py`を動的に書き換えるロジックを実装する。
  - **改修内容**:
      - `run_single_backtest`関数を修正する。
      - `try...finally`ブロックを導入し、ファイルの復元処理を保証する。
      - `try`ブロック内部で、
        1.  `config_evaluation.py`から`BACKTEST_LOG_LEVEL_OVERRIDE`の値を読み込む。
        2.  元の`src/backtest/config_backtest.py`の内容をメモリに保持する。
        3.  `LOG_LEVEL`の行を、読み込んだ上書き設定（例: `LOG_LEVEL = None`）に置換し、ファイルを書き換える。
        4.  バックテストのサブプロセスを実行する。
      - `finally`ブロック内部で、
        1.  メモリに保持しておいた元の内容で`src/backtest/config_backtest.py`を復元する。

#### 4.3.3. `src/evaluation/run_evaluation.py`

  - **目的**: `evaluation`プロセスのエントリーポイントとして、ロガーを正しく初期化する。
  - **改修内容**:
      - `orchestrator.py`の`main`関数からロガー初期化処理を移動させる。
      - スクリプト実行時、`config_evaluation.py`の`LOG_LEVEL`設定を読み込み、`core.util.logger.setup_logging`を呼び出す。

-----

## 5\. 期待される効果

  - **パフォーマンスの大幅な向上**: `evaluation`実行時の不要なログI/Oが完全になくなり、全体の処理時間が大幅に短縮される。
  - **設定の柔軟性と保守性**:
      - `evaluation`のログ設定は`config_evaluation.py`に集約され、変更が容易になる。
      - デバッグ時には`BACKTEST_LOG_LEVEL_OVERRIDE`を`'DEBUG'`に変更するだけで、コードを汚さずに詳細なバックテストログを取得できる。
  - **単体実行時の動作保証**: `backtest`を単独で実行した場合は、`config_backtest.py`で定義されたデフォルトのログレベル(`INFO`)で動作し、開発時の利便性を損なわない。