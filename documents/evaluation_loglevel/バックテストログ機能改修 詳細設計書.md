はい、承知いたしました。
基本仕様書に基づき、実装担当者が具体的な作業に着手できるよう、ファイル単位での変更点を明確にした詳細設計書を作成します。

-----

# バックテストログ機能改修 詳細設計書

## 1\. はじめに

本ドキュメントは、「バックテストログ機能改修 基本仕様書」に基づき、ログ機能改修の実装に必要な技術的詳細を定義するものである。各ファイルの具体的な変更箇所、新規作成するファイルの内容、および改修後の処理フローについて記述する。

## 2\. 改修範囲

本改修では、以下の5ファイルを変更または新規作成する。

| パッケージ | ファイル名 | 状態 | 概要 |
| :--- | :--- | :--- | :--- |
| `core` | `src/core/util/logger.py` | 変更 | ログ無効化モード (`level=None`) への対応 |
| `backtest` | `src/backtest/config_backtest.py` | 変更 | デフォルトログレベルの変更とコメントの追記 |
| `evaluation` | `src/evaluation/config_evaluation.py` | **新規** | `evaluation`用の設定ファイル |
| `evaluation` | `src/evaluation/run_evaluation.py` | 変更 | `evaluation`ロガーの初期化処理の実装 |
| `evaluation` | `src/evaluation/orchestrator.py` | 変更 | `backtest`設定ファイルの一時書き換えロジックの実装 |

-----

## 3\. 詳細設計

### 3.1. 🔧 `core` パッケージ

#### 📝 **`src/core/util/logger.py`**

  - **目的**: ログレベルとして`None`が渡された場合に、ログ出力を完全に無効化する。
  - **変更箇所**: `setup_logging` 関数の先頭に、`level`が`None`である場合の条件分岐を追加する。

**変更前:**

```python
# src/core/util/logger.py
def setup_logging(log_dir, log_prefix, level=logging.INFO):
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)
    # (以降続く)
```

**変更後:**

```python
# src/core/util/logger.py
import logging
import os
from datetime import datetime

def setup_logging(log_dir, log_prefix, level=logging.INFO):
    # ▼▼▼【変更箇所】▼▼▼
    # 渡されたレベルがNoneの場合、ロギングをセットアップせずに関数を抜ける
    if level is None:
        # ライブラリ等からの 'No handlers could be found' 警告を抑制するためにNullHandlerを追加
        logging.getLogger().addHandler(logging.NullHandler())
        return
    # ▲▲▲【変更箇所ここまで】▲▲▲

    if not os.path.exists(log_dir):
        os.makedirs(log_dir)
    # (以降、変更なし)
```

-----

### 3.2. 🔧 `backtest` パッケージ

#### 📝 **`src/backtest/config_backtest.py`**

  - **目的**: バックテスト単体実行時のデフォルトログレベルを`INFO`に下げ、設定が上書きされる可能性があることを明記する。
  - **変更箇所**: `LOG_LEVEL`の定義行を修正する。

**変更前:**

```python
# src/backtest/config_backtest.py
# --- ロギング設定 ---
LOG_LEVEL = logging.DEBUG # INFO or DEBUG
```

**変更後:**

```python
# src/backtest/config_backtest.py
# --- ロギング設定 ---
# ▼▼▼【変更箇所】▼▼▼
# バックテスト単体実行時のデフォルトログレベル。
# evaluation実行時は、この値がconfig_evaluation.pyの設定で一時的に上書きされます。
LOG_LEVEL = logging.INFO # INFO or DEBUG or None
# ▲▲▲【変更箇所ここまで】▲▲▲
```

-----

### 3.3. 🔧 `evaluation` パッケージ

#### 📝 **`src/evaluation/config_evaluation.py` (新規作成)**

  - **目的**: `evaluation`に関する設定を一元管理する。
  - **ファイル内容**:

<!-- end list -->

```python
# src/evaluation/config_evaluation.py
import logging

# ==============================================================================
# ファイル: config_evaluation.py
# 説明: evaluationパッケージ全体の設定を管理します。
# ==============================================================================

# --- ロギング設定 ---

# evaluationモジュール自体のログレベル (INFO, DEBUG など)
LOG_LEVEL = logging.INFO

# evaluationから呼び出すバックテストのログレベルを指定します。
# 'NONE' に設定すると、バックテストのログ出力を完全に抑制し、評価全体の実行を高速化します。
# 個別バックテストの詳細ログを確認したい場合は 'INFO' や 'DEBUG' に変更してください。
BACKTEST_LOG_LEVEL_OVERRIDE = 'NONE'
```

#### 📝 **`src/evaluation/run_evaluation.py`**

  - **目的**: `evaluation`プロセスのエントリーポイントとして、`config_evaluation.py`に基づきロガーを初期化する。
  - **変更箇所**: `if __name__ == '__main__':`ブロック内を修正し、`orchestrator.main()`の呼び出し前にロガー設定処理を追加する。

**変更前:**

```python
# src/evaluation/run_evaluation.py
from src.evaluation.orchestrator import main

if __name__ == '__main__':
    main()
```

**変更後:**

```python
# src/evaluation/run_evaluation.py
# (前略)
# ▼▼▼【変更箇所】▼▼▼
from src.evaluation.orchestrator import main
from src.core.util import logger as logger_setup
from . import config_evaluation as config

if __name__ == '__main__':
    # evaluationモジュール自体のロガーを、設定ファイルに基づいてセットアップ
    logger_setup.setup_logging('log', log_prefix='evaluation', level=config.LOG_LEVEL)
    main()
# ▲▲▲【変更箇所ここまで】▲▲▲
```

#### 📝 **`src/evaluation/orchestrator.py`**

  - **目的**: バックテスト実行時に`config_backtest.py`を一時的に書き換え、処理後に必ず復元するロジックを実装する。
  - **変更箇所**:
    1.  必要なモジュールと設定ファイルをインポートする。
    2.  `run_single_backtest`関数を全面的に書き換え、ファイル操作ロジックを追加する。
    3.  `main`関数からロガー初期化の呼び出しを削除する（`run_evaluation.py`に移動したため）。

**変更前 (主要部分抜粋):**

```python
# src/evaluation/orchestrator.py
from src.core.util import logger as logger_setup
# (中略)
def run_single_backtest(strategy_def, base_config):
    # (中略)
    result = subprocess.run(
        [python_executable, '-m', 'src.backtest.run_backtest'],
        check=True, text=True, encoding=sys.stdout.encoding, errors='replace',
        capture_output=True
    )
    # (中略)

def main():
    # (中略)
    logger_setup.setup_logging('log', log_prefix='evaluation')
    # (後略)
```

**変更後 (主要部分抜粋):**

```python
# src/evaluation/orchestrator.py
# (import文は変更・追加)
from . import aggregator
from . import config_evaluation as config # evaluation専用設定をインポート

# --- 定数定義 ---
# (中略)
BACKTEST_CONFIG_FILE = 'src/backtest/config_backtest.py'
# (後略)

def run_single_backtest(strategy_def, base_config):
    """
    単一の戦略でバックテストを実行します。
    設定ファイルを一時的に書き換え、実行後に必ず元の状態に戻します。
    """
    strategy_name = strategy_def.get('name', 'Unnamed Strategy')
    logging.info(f"--- 戦略 '{strategy_name}' のバックテストを開始 ---")
    
    if strategy_def.get('unsupported'):
        logging.warning(f"戦略 '{strategy_name}' は未サポートのためスキップします。理由: {strategy_def.get('reason', 'N/A')}")
        return False

    # ▼▼▼【変更箇所: 全面的なロジック変更】▼▼▼
    original_strategy_content = None
    original_backtest_config_content = None

    try:
        # 1. 元のバックテスト設定ファイルを読み込んで保持
        with open(BACKTEST_CONFIG_FILE, 'r', encoding='utf-8') as f:
            original_backtest_config_content = f.readlines()

        # 2. バックテスト設定ファイルのログレベルを上書き
        level_override = config.BACKTEST_LOG_LEVEL_OVERRIDE
        # 'NONE' の場合は None を、それ以外は logging.{LEVEL} 形式の文字列を生成
        new_line = f"LOG_LEVEL = None\\n" if level_override == 'NONE' else f"LOG_LEVEL = logging.{level_override}\\n"
        
        modified_config = []
        for line in original_backtest_config_content:
            if line.strip().startswith('LOG_LEVEL ='):
                modified_config.append(new_line)
            else:
                modified_config.append(line)
        
        with open(BACKTEST_CONFIG_FILE, 'w', encoding='utf-8') as f:
            f.writelines(modified_config)
        logging.info(f"バックテストのログレベルを '{level_override}' に一時変更しました。")
        
        # (戦略ファイルの一時書き換え処理は変更なし)
        # ...

        # 3. バックテストのサブプロセスを実行
        python_executable = sys.executable
        result = subprocess.run(
            [python_executable, '-m', 'src.backtest.run_backtest'],
            check=True, text=True, encoding=sys.stdout.encoding, errors='replace',
            capture_output=True
        )

        if result.stdout: logging.info(f"--- 'run_backtest' の出力 ---\\n{result.stdout.strip()}")
        logging.info("'run_backtest' が正常に完了しました。")
        return True

    except Exception as e:
        logging.error(f"バックテスト実行中にエラーが発生: {e}", exc_info=True)
        if isinstance(e, subprocess.CalledProcessError):
            if e.stdout: logging.error(f"--- STDOUT ---\\n{e.stdout.strip()}")
            if e.stderr: logging.error(f"--- STDERR ---\\n{e.stderr.strip()}")
        return False
    
    finally:
        # 4. 必ず元のファイル内容に復元
        if original_backtest_config_content:
            with open(BACKTEST_CONFIG_FILE, 'w', encoding='utf-8') as f:
                f.writelines(original_backtest_config_content)
            logging.info(f"'{BACKTEST_CONFIG_FILE}' を元の状態に復元しました。")
    # ▲▲▲【変更箇所ここまで】▲▲▲

def main():
    # (前略)
    # ▼▼▼【変更箇所: ロガー初期化呼び出しを削除】▼▼▼
    # logger_setup.setup_logging('log', log_prefix='evaluation') # この行はrun_evaluation.pyに移動
    # ▲▲▲【変更箇所ここまで】▲▲▲
    # (後略)
```

-----

## 4\. 実装フローの検証

改修後の`evaluation`実行時の処理フローは以下の通りとなる。

1.  ユーザーが `python -m src.evaluation.run_evaluation` を実行する。
2.  `run_evaluation.py` が `config_evaluation.py` を読み込み、`evaluation`自体のロガーを `INFO` レベルで初期化する。
3.  `orchestrator.main()` が呼び出され、戦略ループが開始される。
4.  `run_single_backtest` 関数が呼び出される。
5.  `config_backtest.py` の内容が読み込まれ、メモリに保持される。
6.  `BACKTEST_LOG_LEVEL_OVERRIDE` ('NONE') に基づき、`config_backtest.py` の `LOG_LEVEL` が `LOG_LEVEL = None` に書き換えられる。
7.  `run_backtest` のサブプロセスが起動する。
8.  サブプロセスは、書き換えられた `config_backtest.py` を読み込み、ロガーのレベルを `None` で初期化する。
9.  `core.util.logger.setup_logging` は `level=None` を検知し、ハンドラーを一切設定しない。結果、バックテスト中のログは一切出力されない。
10. サブプロセスが終了する。
11. `run_single_backtest` の `finally` ブロックが実行され、メモリに保持していた元の内容で `config_backtest.py` を復元する (`LOG_LEVEL = logging.INFO` に戻る)。
12. 次の戦略で4〜11の処理が繰り返される。

## 5\. テスト・確認項目

  - ✅ `python -m src.evaluation.run_evaluation` を実行し、`backtest_*.log` ファイルが**生成されない**こと、および実行が高速化されることを確認する。
  - ✅ `python -m src.backtest.run_backtest` を単体で実行し、`backtest_*.log` ファイルが**生成され**、`INFO`レベルのログが出力されることを確認する。
  - ✅ `src/evaluation/config_evaluation.py` の `BACKTEST_LOG_LEVEL_OVERRIDE` を `'DEBUG'` に変更し、`evaluation` を実行する。各戦略に対応する `backtest_*.log` ファイルが**生成され**、`DEBUG`レベルの詳細なログが出力されることを確認する。
  - ✅ `evaluation` 実行後、`src/backtest/config_backtest.py` の内容が元の `LOG_LEVEL = logging.INFO` に戻っていることを確認する。