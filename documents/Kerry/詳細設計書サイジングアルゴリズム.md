承知いたしました。
基本仕様書 に基づき、ケリー基準サイジング機能の実装に必要な変更点をまとめた「詳細設計書」をMarkdown形式で作成します。

-----

# 詳細設計書: サイジングアルゴリズム V2.0

  * **バージョン:** 2.0
  * **日付:** 2025年11月12日
  * **ドキュメント:** 詳細設計書
  * **目的:** 基本仕様書 に基づき、ケリー基準サイジングのロジックを実装し、既存の「リスクベース」方式と切り替え可能にするための詳細な変更点を定義する。

## 1\. 変更対象コンポーネント

本改修では、以下の4つのコンポーネント（`create_*.py` ファイル）に含まれるモジュールを修正する。

1.  `create_strategy.py` (設定ファイルの定義)
2.  `create_core.py` (中核となるサイジングロジックの変更)
3.  `create_realtrade.py` (リアルタイム取引へのケリー基準値の連携)
4.  `create_backtest.py` (バックテスト実行時の方式選択)

## 2\. 詳細設計

### 2.1. `create_strategy.py` (設定ファイルの定義)

`config/strategy_base.yml` を改修し、バックテストとリアルタイム取引でサイジング方式を個別に指定できるようにする。

  * **対象ファイル:** `create_strategy.py`
  * **対象キー:** `project_files["config/strategy_base.yml"]`
  * **変更内容:** `sizing:` ブロックを、基本仕様書 で合意した以下の構造で**完全に置き換える**。

<!-- end list -->

```yaml
# create_strategy.py -> project_files["config/strategy_base.yml"] に反映

sizing:
  # === 方式選択 ===
  # 'risk_based' (リスクベース方式)
  # 'kelly_criterion' (ケリー基準方式)
  backtest_method: 'risk_based'
  realtrade_method: 'risk_based'

  # === (A) リスクベース方式の設定 ===
  risk_based:
    risk_per_trade: 0.01 # 1トレードあたりのリスク(資金に対する割合)

  # === (B) ケリー基準方式の設定 ===
  kelly_criterion:
    # f値（投資比率）のソースを指定
    # 'adjusted': 評価(evaluation)で算出した調整済みf値 (Kelly_Adj) を使用
    # 'raw': 評価(evaluation)で算出した生f値 (Kelly_Raw) を使用
    # 'fixed': 下記の 'fixed_f_value' を使用
    f_value_source: 'adjusted' 
    
    # 'fixed' を選んだ場合の固定f値
    fixed_f_value: 0.1 

    # f値の上限 (Fractional Kelly)
    max_f_value_cap: 0.25 

  # === (C) 共通の制約 ===
  max_investment_per_trade: 10000000 # 1トレードあたりの最大投資額(円)
```

-----

### 2.2. `create_core.py` (中核ロジックの実装)

中核となる `BaseOrderManager` を改修し、コンテキスト（BT/RT）に応じて解決済みの `method` と `statistics` を受け取れるようにし、`place_entry_order` のロジックを分岐させる。

  * **対象ファイル:** `create_core.py`
  * **対象モジュール:** `project_files["src/core/strategy/order_manager.py"]`
  * **対象クラス:** `BaseOrderManager`

#### 2.2.1. `BaseOrderManager` `__init__` メソッドの変更

コンストラクタのシグネチャ（引数）を、`method` 文字列と `statistics` 辞書を受け取れるよう変更する。

  * **変更前**:
    ```python
    def __init__(self, strategy, sizing_params, event_handler):
        self.strategy = strategy
        self.sizing_params = sizing_params
        self.event_handler = event_handler
    ```
  * **変更後 (置換):**
    ```python
    def __init__(self, strategy, sizing_params, method: str, event_handler, statistics=None):
        self.strategy = strategy
        self.sizing_params = sizing_params # sizing_params 全体は引き続き保持
        self.method = method # 実行コンテキストで解決済みの method 文字列
        self.event_handler = event_handler
        self.statistics = statistics if statistics else {} # ケリー基準値
    ```

#### 2.2.2. `BaseOrderManager` `place_entry_order` メソッドの置換

サイジングロジックの分岐を実装するため、メソッド全体を以下のロジックで**完全に置き換える**。

  * **変更後 (置換):**
    ```python
    def place_entry_order(self, trade_type, reason, indicators):
        """
        [改修] リスクベース方式とケリー基準方式を切り替えてエントリー注文を発注する。
        """
        exit_signal_generator = self.strategy.exit_signal_generator
        entry_price = self.strategy.datas[0].close[0]
        is_long = trade_type == 'long'
        
        # 1. 決済価格と1株あたりリスクを計算 (両方式で必要)
        exit_signal_generator.calculate_and_set_exit_prices(entry_price, is_long)
        risk_per_share = exit_signal_generator.risk_per_share

        # self.method は __init__ で渡された解決済みの方式
        method = self.method 

        # 1株あたりリスクが0の場合、リスクベース方式は使えない
        if risk_per_share < 1e-9 and method == 'risk_based':
            self.strategy.logger.log("リスクベース方式が選択されていますが、計算されたリスクが0のためエントリーをスキップ。")
            return

        cash = self.strategy.broker.getcash()
        max_investment = self.sizing_params.get('max_investment_per_trade', 1e7)
        
        size1 = 0.0 # 方式に基づいて計算されるサイズ

        # --- サイジング方式の分岐 ---
        
        if method == 'risk_based':
            # === (A) リスクベース方式 ===
            risk_params = self.sizing_params.get('risk_based', {})
            risk_per_trade_pct = risk_params.get('risk_per_trade', 0.01)
            risk_capital = cash * risk_per_trade_pct
            
            size1 = risk_capital / risk_per_share
            self.strategy.logger.log(f"サイジング (リスクベース): 資金={cash:,.0f}, リスク許容={risk_capital:,.0f} (1株リスク={risk_per_share:,.1f}) -> size1={size1:,.2f}")

        elif method == 'kelly_criterion':
            # === (B) ケリー基準方式 ===
            kelly_params = self.sizing_params.get('kelly_criterion', {})
            f_source = kelly_params.get('f_value_source', 'adjusted')
            max_f_value_cap = kelly_params.get('max_f_value_cap', 0.25)
            f_value = 0.0 # 決定された投資比率 (f値)
            
            if f_source == 'fixed':
                f_value = kelly_params.get('fixed_f_value', 0.1)
                self.strategy.logger.log(f"ケリー基準 (固定f値): f={f_value:.4f}")

            elif not self.statistics:
                # 統計情報なし (主にバックテスト時)
                self.strategy.logger.log(f"ケリー基準: '{f_source}' が選択されましたが、統計情報(statistics)がありません。f=0として処理します。")
                f_value = 0.0
            
            elif f_source == 'adjusted':
                try: f_value = float(self.statistics.get('Kelly_Adj', 0.0))
                except (ValueError, TypeError): f_value = 0.0
                self.strategy.logger.log(f"ケリー基準 (調整済): 統計 'Kelly_Adj'={self.statistics.get('Kelly_Adj')} -> f={f_value:.4f}")

            elif f_source == 'raw':
                try: f_value = float(self.statistics.get('Kelly_Raw', 0.0))
                except (ValueError, TypeError): f_value = 0.0
                if f_value < 0: f_value = 0.0 # マイナスf値は0に丸める
                self.strategy.logger.log(f"ケリー基準 (生): 統計 'Kelly_Raw'={self.statistics.get('Kelly_Raw')} -> f={f_value:.4f}")

            else:
                self.strategy.logger.log(f"警告: 不明なケリー方式 '{f_source}'。f=0でスキップします。")
                f_value = 0.0

            # f値の上限を適用 (Fractional Kelly)
            if f_value > max_f_value_cap:
                self.strategy.logger.log(f"ケリー基準: f値 {f_value:.4f} が上限 {max_f_value_cap:.4f} を超えたため調整。")
                f_value = max_f_value_cap

            if f_value <= 0:
                if f_value < 0: self.strategy.logger.log(f"ケリー基準: f値がマイナス ({f_value:.4f}) のためエントリーをスキップ。")
                return

            investment_capital = cash * f_value # 投資額（円）
            
            if entry_price > 0:
                size1 = investment_capital / entry_price
                self.strategy.logger.log(f"サイジング (ケリー基準): 資金={cash:,.0f}, f値={f_value:.4f}, 投資額={investment_capital:,.0f} (株価={entry_price:,.1f}) -> size1={size1:,.2f}")
            else:
                self.strategy.logger.log("ケリー基準: 株価が0のためスキップ。")
                return
        
        else:
            self.strategy.logger.log(f"警告: 不明なサイジング方式 '{method}'。エントリーをスキップします。")
            return

        # --- 共通の制約を適用 ---
        if entry_price <= 0: 
            self.strategy.logger.log(f"サイジング: エントリー価格が0のためスキップ。")
            return

        # (Size 2) 最大投資額ベースのサイズ
        size2 = max_investment / entry_price
        self.strategy.logger.log(f"サイジング (制約): 最大投資額={max_investment:,.0f} (株価={entry_price:,.1f}) -> size2={size2:,.2f}")
        
        # (最終数量) (リスクベース or ケリー基準) と (最大投資額) の小さい方を採用
        size = min(size1, size2)
        self.strategy.logger.log(f"サイジング (最終): min(size1, size2) -> 最終数量={size:,.2f}")

        if size <= 0: return

        self.strategy.entry_order = self.strategy.buy(size=size) if is_long else self.strategy.sell(size=size)

        # イベントハンドラ呼び出し
        self.event_handler.on_entry_order_placed(
            trade_type=trade_type, size=size, reason=reason,
            entry_price=entry_price,
            tp_price=exit_signal_generator.tp_price, sl_price=exit_signal_generator.sl_price
        )
    ```

-----

### 2.3. `create_realtrade.py` (リアルタイム取引の実装)

リアルタイム取引において、ケリー基準値 (`statistics`) と実行方式 (`method`) を `OrderManager` まで連携させる。

#### 2.3.1. `RealtimeTrader` の改修 (`run_realtrade.py`)

  * **対象:** `project_files["src/realtrade/run_realtrade.py"]`

  * **変更内容:**

    1.  `__init__`: `_load_strategy_assignments` を `_load_trade_data` に変更。`all_recommend_*.csv` から `DataFrame` をロードし、`self.strategy_assignments` (辞書) と `self.statistics_map` (辞書) を生成する。
    2.  `__init__`: `CerebroFactory` のコンストラクタに `self.statistics_map` を渡す。
    3.  `_load_trade_data` (旧 `_load_strategy_assignments`): `pd.read_csv` した `DataFrame` を返すよう変更する。

  * **コード (抜粋):**

    ```python
    # src/realtrade/run_realtrade.py (RealtimeTrader クラス)

    def __init__(self):
        # ... (設定ファイルの読み込みは変更なし) ...
        self.base_strategy_params = self._load_yaml(os.path.join(config.BASE_DIR, 'config', 'strategy_base.yml'))
        
        # ▼▼▼ (変更) 統計情報の読み込みとマップ作成 ▼▼▼
        self.trade_data = self._load_trade_data(config.RECOMMEND_FILE_PATTERN)
        
        self.strategy_assignments = pd.Series(
            self.trade_data['戦略名'].values, 
            index=self.trade_data['銘柄'].astype(str)
        ).to_dict()
        
        self.statistics_map = {}
        cols_to_load = ['Kelly_Adj', 'Kelly_Raw'] # 両方読み込む
        for _, row in self.trade_data.iterrows():
            key = (row['戦略名'], str(row['銘柄']))
            stats = {col: row[col] for col in cols_to_load if col in row}
            self.statistics_map[key] = stats

        self.symbols = list(self.strategy_assignments.keys())
        # ▲▲▲ (変更)
        
        # ... (状態変数、Connectorの初期化は変更なし) ...

        # ▼▼▼ (変更) Factory に statistics_map を渡す ▼▼▼
        self.factory = CerebroFactory(
            self.strategy_catalog, 
            self.base_strategy_params, 
            config.DATA_DIR,
            self.statistics_map # <-- 新規追加
        )
        # ▲▲▲ (変更)
        self.synchronizer = PositionSynchronizer(self.connector, self.strategy_instances, self.stop_event)

    def _load_yaml(self, fp):
        with open(fp, 'r', encoding='utf-8') as f: return yaml.safe_load(f)
        
    # ▼▼▼ (変更) メソッド名を変更し、DataFrame全体を返す ▼▼▼
    def _load_trade_data(self, pattern):
        files = glob.glob(pattern)
        if not files: raise FileNotFoundError(f"Recommendation file not found: {pattern}")
        latest_file = max(files, key=os.path.getctime)
        logger.info(f"Loading recommended strategies and stats from: {latest_file}")
        df = pd.read_csv(latest_file)
        if 'Kelly_Adj' not in df.columns or 'Kelly_Raw' not in df.columns:
            logger.warning(f"警告: {latest_file} に 'Kelly_Adj' または 'Kelly_Raw' が見つかりません。")
        return df
    # ▲▲▲ (変更)

    # ... (start, stop 等の残りのメソッドは変更なし) ...
    ```

#### 2.3.2. `CerebroFactory` の改修 (`cerebro_factory.py`)

  * **対象:** `project_files["src/realtrade/cerebro_factory.py"]`

  * **変更内容:**

    1.  `__init__`: `statistics_map` を受け取り、`self.statistics_map` に保存する。
    2.  `create_instance`: `strategy_components` に、該当する銘柄/戦略の `statistics` を詰めて `RealTradeStrategy` に渡す。

  * **コード (抜粋):**

    ```python
    # src/realtrade/cerebro_factory.py (CerebroFactory クラス)

    # ▼▼▼ (変更) __init__ で statistics_map を受け取る
    def __init__(self, strategy_catalog, base_strategy_params, data_dir, statistics_map):
        self.strategy_catalog = strategy_catalog
        self.base_strategy_params = base_strategy_params
        self.data_dir = data_dir
        self.statistics_map = statistics_map # <-- 新規追加
        logger.info("CerebroFactory initialized.")
    # ▲▲▲ (変更)

    def create_instance(self, symbol: str, strategy_name: str, connector):
        # ... (strategy_params の構築ロジックは変更なし) ...

        try:
            # ... (cerebro, broker, data feed のセットアップは変更なし) ...
            
            # ▼▼▼ (変更) 統計情報を strategy_components に詰めて渡す
            stats_key = (strategy_name, str(symbol))
            symbol_statistics = self.statistics_map.get(stats_key, {})
            if not symbol_statistics:
                logger.warning(f"[{symbol}] 戦略 '{strategy_name}' の統計情報(ケリー基準)が見つかりません。")

            strategy_components = {
                'statistics': symbol_statistics
            }
            
            cerebro.addstrategy(
                RealTradeStrategy, 
                strategy_params=strategy_params, 
                strategy_components=strategy_components # <-- 変更
            )
            # ▲▲▲ (変更)
            
            # ... (return cerebro) ...
    ```

#### 2.3.3. `RealTradeStrategy` の改修 (`strategy.py`)

  * **対象:** `project_files["src/realtrade/strategy.py"]`

  * **変更内容:** `_setup_components` 内で、`sizing_params['realtrade_method']` と `components.get('statistics')` を取得し、`RealTradeOrderManager` の `__init__` に渡す。

  * **コード (抜粋):**

    ```python
    # src/realtrade/strategy.py (RealTradeStrategy クラス)

    def _setup_components(self, params, components):
        # ▼▼▼ (変更) 'realtrade_method' と statistics を読み取り、OrderManager に渡す
        state_manager = components.get('state_manager')
        statistics = components.get('statistics') # <-- 新規追加
        sizing_params = params.get('sizing', {})

        # (新規) リアルタイム取引用のサイジング方式を取得
        method = sizing_params.get('realtrade_method', 'risk_based')
        
        notifier = RealTradeStrategyNotifier(self)
        self.event_handler = RealTradeEventHandler(self, notifier, state_manager=state_manager)
        
        # (変更) OrderManager に method, statistics を渡す
        self.order_manager = RealTradeOrderManager(
            self, 
            sizing_params,
            method, # <-- 新規追加
            self.event_handler,
            statistics=statistics # <-- 新規追加
        )
        self.exit_signal_generator = RealTradeExitSignalGenerator(self, self.order_manager)
        # ▲▲▲ (変更)
    ```

#### 2.3.4. `RealTradeOrderManager` の改修 (`implementations/order_manager.py`)

  * **対象:** `project_files["src/realtrade/implementations/order_manager.py"]`

  * **変更内容:** `BaseOrderManager` の `__init__` 変更（2.2.1）に対応するため、`__init__` を定義し、引数を `super()` に渡す。

  * **コード (抜粋):**

    ```python
    # src/realtrade/implementations/order_manager.py (RealTradeOrderManager クラス)

    # ▼▼▼ (新規) __init__ を追加
    def __init__(self, strategy, sizing_params, method, event_handler, statistics=None):
        # BaseOrderManager の __init__ を呼び出す
        super().__init__(strategy, sizing_params, method, event_handler, statistics=statistics)
    # ▲▲▲ (新規)

    # (既存の pass は削除)
    ```

-----

### 2.4. `create_backtest.py` (バックテストの実装)

バックテストにおいて、`backtest_method` を `OrderManager` まで連携させる。

#### 2.4.1. `BacktestStrategy` の改修 (`strategy.py`)

  * **対象:** `project_files["src/backtest/strategy.py"]`

  * **変更内容:** `_setup_components` 内で、`sizing_params['backtest_method']` を取得し、`BacktestOrderManager` の `__init__` に渡す。

  * **コード (抜粋):**

    ```python
    # src/backtest/strategy.py (BacktestStrategy クラス)

    def _setup_components(self, params, components):
        # ▼▼▼ (変更) 'backtest_method' を読み取り、OrderManager に渡す
        sizing_params = params.get('sizing', {})
        
        # (新規) バックテスト用のサイジング方式を取得
        method = sizing_params.get('backtest_method', 'risk_based')
        
        notifier = BacktestStrategyNotifier(self)
        self.event_handler = BacktestEventHandler(self, notifier)
        
        # (変更) OrderManager に method を渡す
        self.order_manager = BacktestOrderManager(
            self, 
            sizing_params, 
            method, # <-- 新規追加
            self.event_handler
            # statistics=None (バックテストでは統計情報なし)
        )
        self.exit_signal_generator = BacktestExitSignalGenerator(self, self.order_manager)
        # ▲▲▲ (変更)
    ```

#### 2.4.2. `BacktestOrderManager` の改修 (`implementations/order_manager.py`)

  * **対象:** `project_files["src/backtest/implementations/order_manager.py"]`

  * **変更内容:** `BaseOrderManager` の `__init__` 変更（2.2.1）に対応するため、`__init__` を定義し、引数を `super()` に渡す。

  * **コード (抜粋):**

    ```python
    # src/backtest/implementations/order_manager.py (BacktestOrderManager クラス)

    # ▼▼▼ (新規) __init__ を追加
    def __init__(self, strategy, sizing_params, method, event_handler):
        # BaseOrderManager の __init__ を呼び出す
        # バックテストでは statistics は常に None
        super().__init__(strategy, sizing_params, method, event_handler, statistics=None)
    # ▲▲▲ (新規)

    def place_backtest_exit_orders(self):
        # ... (このメソッドは変更なし) ...
    ```

-----