はい、承知いたしました。
採用された `bar_builder.py` を反映し、基本仕様書と詳細設計書を更新しました。

-----

## 【更新版】基本仕様書：リアルタイム5分足生成機能

### 1\. 概要

本仕様書は、株式自動売買システムにおけるリアルタイムトレード機能の改善を目的とし、Excelから取得するリアルタイム価格情報（Tickデータ）を元に、正確な\*\*5分足（OHLCV）\*\*を動的に生成する機能の仕様を定義するものである。

-----

### 2\. 背景と目的

#### 2.1. 現状の課題

現在のリアルタイムトレード（RAKUTENモード）では、Excelからの価格更新があるたびに、その瞬間の価格情報で新しい「足」を生成し、短期データフィードとして利用している。この方式では、時間で区切られた正確な始値・高値・安値・終値・出来高（OHLCV）を表現できず、バックテストで使用するデータとの乖離が生じ、分析の精度に影響を与える可能性がある。

#### 2.2. 目的

本改修の目的は、リアルタイムのTickデータストリームを集約し、**時間ベースで正確な5分足データを生成する**ロジックを実装することにある。これにより、リアルタイム分析の精度を向上させ、バックテストとの一貫性を確保する。

-----

### 3\. 基本方針

本機能の実現のため、以下の基本方針に沿って実装を進める。

1.  **責務の分離**: Tickデータを集約して足を生成する責務を持つ新コンポーネント **`BarBuilder`** を導入する。
2.  **責務の変更**: 既存のデータフィード `RakutenData` は、**`BarBuilder`** を利用して完成した5分足のみをBacktraderエンジンに供給する役割に変更する。
3.  **データの正確性**: Excelから取得する累計出来高から、5分間の**差分出来高**を正確に計算するロジックを組み込む。

-----

### 4\. 詳細仕様

#### 4.1. ⚙️ 新規コンポーネント: `BarBuilder`

リアルタイムTickデータを集約し、指定された時間枠の足を生成する機能を提供する。

  * **配置場所**: `src/realtrade/bar_builder.py`
  * **責務**:
      * Tickデータ（タイムスタンプ、価格、累計出来高）を受け取る。
      * Tickが属する5分間の時間枠（例: 09:05:00 - 09:09:59）を特定する。
      * 時間枠内のOHLCVを以下のように決定する。
          * **始値 (Open)**: 期間内の最初のTick価格
          * **高値 (High)**: 期間内の最高価格
          * **安値 (Low)**: 期間内の最安価格
          * **終値 (Close)**: 期間内の最新（最後）のTick価格
          * **出来高 (Volume)**: 期間内の累計出来高の差分
      * 時間枠が切り替わるタイミングで、完成した1本の足を返す。
  * **主要メソッド**:
      * `__init__(self, interval_minutes=5)`:
          * 足生成の時間間隔（分）を指定してインスタンスを初期化する。
      * `add_tick(self, timestamp, price, cumulative_volume)`:
          * Tickデータを受け取り、内部で足を形成する。
          * 足が完成した（時間枠が切り替わった）瞬間に、完成した足データを返す。
          * 足がまだ形成中の場合は `None` を返す。

-----

#### 4.2. 🔄 既存コンポーネントの修正: `RakutenData`

**`BarBuilder`** を利用し、Backtraderへ正確な5分足を供給するようにロジックを修正する。

  * **修正対象**: `src/realtrade/rakuten/rakuten_data.py`
  * **修正内容**:
      * **`__init__` メソッド**:
          * **`BarBuilder`** のインスタンスを生成し、メンバ変数として保持する。
            ```python
            from src.realtrade.bar_builder import BarBuilder
            # ...
            self.builder = BarBuilder(interval_minutes=5)
            ```
      * **`_load` メソッド**:
          * Excelから最新の価格情報を取得後、その情報を直接Backtraderに供給するのではなく、`self.builder.add_tick()` メソッドに渡す。
          * `self.builder` から完成した足が返された場合のみ、その足の情報を `_populate_lines` を使ってBacktraderに供給する。
          * `self.builder` から `None` が返された場合は、Backtraderには新しい足がないことを示し、次の処理サイクルに進む。

-----

### 5\. 処理フロー

1.  **`ExcelConnector`**: 1秒ごとにExcelからリアルタイムの `価格` と `累計出来高` を取得。
2.  **`RakutenData`**: 取得したTick情報を **`BarBuilder`** インスタンスの `add_tick` メソッドに渡す。
3.  **`BarBuilder`**:
      * **形成中**: Tick情報に基づき、内部で管理する現在の5分足のH/L/C/Vを更新。`None` を返す。
      * **完成時**: 時間枠が切り替わった場合、完成した5分足データを `RakutenData` に返す。
4.  **`RakutenData`**: **`BarBuilder`** から完成した足データを受け取った場合のみ、Backtraderに新しい足として供給する。
5.  **`Backtrader` Engine**: 供給された正確な5分足に基づき、中期・長期足のリサンプリング、指標計算、戦略評価を実行する（既存ロジックの変更は不要）。

-----

### 6\. 考慮事項

#### 6.1. 出来高の計算

この設計は、5分間の正確な**期間内出来高**を算出するためのものです。

  * **担当コンポーネント**: `BarBuilder` クラス
  * **設計詳細**:
    1.  `BarBuilder` は、`_last_cumulative_volume` というメンバ変数を持ち、最後に処理したTickの累計出来高を記憶します。この変数はインスタンス生成時に `0` で初期化されます。
    2.  `add_tick` メソッドが新しいTickデータ（`timestamp`, `price`, `cumulative_volume`）を受け取ると、以下の計算を行います。
        ```python
        # BarBuilder.add_tick() 内の処理

        # 差分（期間内）出来高を計算
        if self._last_cumulative_volume > 0:
            tick_volume = cumulative_volume - self._last_cumulative_volume
        else:
            # セッション開始後、最初のTickの場合
            tick_volume = cumulative_volume

        # 形成中のバーの出来高に加算
        self._current_bar['volume'] += tick_volume

        # 最後に処理した累計出来高を更新
        self._last_cumulative_volume = cumulative_volume
        ```
    3.  この仕組みにより、`BarBuilder` は常に直前のTickからの出来高の差分のみを算出し、それを形成中の5分足の出来高として累積していきます。

#### 6.2. 取引終了時の最終バーの処理

これは、取引終了時に作りかけの最後の5分足（例: 15:25〜15:30のバー）をデータロスなく処理するための「**フラッシュ処理**」の設計です。

  * **担当コンポーネント**: `RealtimeTrader`, `RakutenData`, `BarBuilder` の連携

  * **設計詳細**:
    この処理は、シャットダウンの合図から始まり、各コンポーネントが連鎖的にデータの掃き出し処理を呼び出すことで実現されます。

    1.  **トリガー**: ユーザーがプログラムを終了させる（例: Ctrl+Cを押す）と、最終的に `RealtimeTrader` の `stop()` メソッドが呼び出されます。
    2.  **`RealtimeTrader.stop()`**: データフィードを停止させる**直前**に、保持しているデータフィード（`cerebro.datas[0]`）の `flush()` メソッドを呼び出す処理を追加します。
        ```python
        # RealtimeTrader.stop() 内の処理

        # ...
        # 各Cerebroインスタンスのデータフィードに対してflushを指示
        for cerebro in self.cerebro_instances:
            if cerebro.datas and hasattr(cerebro.datas[0], 'flush'):
                cerebro.datas[0].flush() # <-- flush処理を呼び出す

        # ...その後にデータフィードの停止やスレッドの終了処理を行う...
        ```
    3.  **`RakutenData.flush()`**: この新しいメソッドは、内部で保持する `BarBuilder` インスタンスの `flush()` を呼び出します。
    4.  **`BarBuilder.flush()`**: このメソッドは、`_current_bar` に保持されている形成途中のバーを**強制的に完成させて返し**、内部状態をリセットします。
    5.  **`RakutenData.flush()`**: `BarBuilder` から返された最後のバーを受け取り、`_populate_lines` を使ってBacktraderエンジンに供給します。

    この一連の流れにより、アプリケーション終了時に最後のバーが破棄されることなく、指標計算や分析の対象に含めることが保証されます。

#### 6.3. 取引時間外のデータ

これは、取引時間（例: 9:00〜15:30）以外のデータや、昼休み（11:30〜12:30）のデータをフィルタリングするための設計です。

  * **担当コンポーネント**: `RakutenData` クラス

  * **設計詳細**:
    このフィルタリングは、Tickデータを `BarBuilder` に渡す**前**に行うのが最も効率的です。

    1.  `RakutenData` の `_load` メソッド内で、`ExcelConnector` から最新データを取得した直後に、そのデータのタイムスタンプを検証します。

    2.  現在時刻が日本の証券取引所の取引時間内であるかを判定するロジックを追加します。

        ```python
        # RakutenData._load() 内の処理
        from datetime import time

        # ...Excelからlatest_dataを取得...

        current_dt = datetime.now()
        current_time = current_dt.time()

        # 取引時間外であればTickを無視する
        is_morning_session = time(9, 0) <= current_time <= time(11, 30)
        is_afternoon_session = time(12, 30) <= current_time <= time(15, 30) # <-- 修正箇所

        if not (is_morning_session or is_afternoon_session):
            return None # 何もせず、次のポーリングを待つ

        # 取引時間内であれば、BarBuilderにTickを渡す処理に進む
        # self.builder.add_tick(...)
        ```

    3.  このチェックにより、`BarBuilder` は取引時間内の有効なTickデータのみを受け取ることが保証され、不要なバーが生成されるのを防ぎます。祝日などで取引がない日も、価格更新が発生しないため、このロジックで自動的に対応できます。
