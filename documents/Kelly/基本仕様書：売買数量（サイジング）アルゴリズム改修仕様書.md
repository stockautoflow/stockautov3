大変失礼いたしました。私の意図の読み違えです。「設定ファイル（YAML）そのもの」ではなく、「**今回合意した改修内容をまとめた仕様書（Markdown形式）**」を作成する、ということですね。

承知いたしました。
ご提示いただいた全コードファイル に基づき、今回合意した「ケリー基準サイジング機能の追加」に関する基本仕様書をMarkdown形式で作成します。

-----

# 売買数量（サイジング）アルゴリズム改修仕様書

  * **バージョン:** 2.0
  * **作成日:** 2025年11月11日
  * **担当:** Gemini

## 1\. 概要

本改修の目的は、株式自動トレードシステムにおける売買数量（サイジング）の決定ロジックを強化することにある。

現状の「リスクベース方式」に加え、新たに「ケリー基準方式」を導入する。これにより、バックテスト（`run_backtest.py`） とリアルタイム取引（`run_realtrade.py`） のそれぞれで、どちらのサイジング方式を使用するかを設定ファイルから選択可能にする。

## 2\. 背景：現状の仕様 (v1.0)

現状のサイジングは `src/core/strategy/order_manager.py` の `BaseOrderManager` が担う「リスクベース方式」のみである。

1.  **入力:**
      * `sizing.risk_per_trade` (例: 0.01)
      * `sizing.max_investment_per_trade` (例: 10,000,000)
      * `risk_per_share` (ATRベースの1株あたりSL額)
2.  **ロジック:**
      * `Size 1 = (総資金 * risk_per_trade) / risk_per_share`
      * `Size 2 = max_investment_per_trade / エントリー価格`
      * **最終数量 = `min(Size 1, Size 2)`**

## 3\. 改修仕様 (v2.0)

### 3.1. 設定 (`config/strategy_base.yml`)

`sizing:` ブロックを改修し、バックテストとリアルタイム取引で個別に方式を選択可能にする。

```yaml
sizing:
  # === 方式選択 ===
  # 'risk_based' (リスクベース方式)
  # 'kelly_criterion' (ケリー基準方式)
  backtest_method: 'risk_based'
  realtrade_method: 'risk_based'

  # === (A) リスクベース方式の設定 ===
  risk_based:
    risk_per_trade: 0.01 

  # === (B) ケリー基準方式の設定 ===
  kelly_criterion:
    # f値(投資比率)のソースを指定
    # 'adjusted': 評価(evaluation)で算出した調整済みf値 (Kelly_Adj) を使用
    # 'raw': 評価(evaluation)で算出した生f値 (Kelly_Raw) を使用
    # 'fixed': 下記の 'fixed_f_value' を使用
    f_value_source: 'adjusted' 
    
    # 'fixed' を選んだ場合の固定f値
    fixed_f_value: 0.1 

    # f値の上限 (Fractional Kelly)
    max_f_value_cap: 0.25 

  # === (C) 共通の制約 ===
  max_investment_per_trade: 10000000 
```

### 3.2. データフロー（ケリー基準値の取得）

`realtrade_method: 'kelly_criterion'` が選択された場合、`evaluation` が算出したケリー基準値 (`Kelly_Adj`, `Kelly_Raw`) が必要となる。

1.  **データソース:** `create_evaluation.py` の `aggregator.py` が生成する最新の `all_recommend_*.csv`。このCSVは「銘柄」「戦略名」「Kelly\_Adj」「Kelly\_Raw」を含む。
2.  **読み込み:** `src/realtrade/run_realtrade.py` の `RealtimeTrader` が起動時に `all_recommend_*.csv` を読み込み、`DataFrame` として保持する。
3.  **マップ作成:** `RealtimeTrader` は、`DataFrame` から以下の2つのマップを作成する。
      * `strategy_assignments`: `{ 銘柄コード -> 戦略名 }`
      * `statistics_map`: `{ (戦略名, 銘柄コード) -> {Kelly_Adj: "0.10", Kelly_Raw: "0.18"} }`
4.  **データ連携:**
      * `RealtimeTrader` は `statistics_map` を `CerebroFactory` の `__init__` に渡す。
      * `CerebroFactory` は `create_instance` 時、該当する `(戦略名, 銘柄)` の `symbol_statistics` （例: `{Kelly_Adj: "0.10", ...}`）を `statistics_map` から取得する。
      * `symbol_statistics` は `strategy_components={'statistics': ...}` 経由で `RealTradeStrategy` に渡される。

### 3.3. コアロジック (`BaseOrderManager`) の改修

`src/core/strategy/order_manager.py` の `BaseOrderManager` を改修し、コンテキスト（BT/RT）に応じて解決済みの `method` を受け取るようにする。

#### 3.3.1. `__init__` のシグネチャ変更

`BaseOrderManager` および、それを継承する `BacktestOrderManager` と `RealTradeOrderManager` の `__init__` メソッドを以下のシグネチャに変更する。

```python
def __init__(self, strategy, sizing_params, method: str, event_handler, statistics=None):
    self.strategy = strategy
    self.sizing_params = sizing_params # sizing_params 全体
    self.method = method # 解決済みの方式 ('risk_based' or 'kelly_criterion')
    self.event_handler = event_handler
    self.statistics = statistics if statistics else {}
```

#### 3.3.2. `place_entry_order` のロジック

`self.method` の値に応じて、`size1` の計算ロジックを分岐させる。

1.  **`method == 'risk_based'` の場合 (現状維持)**

      * `risk_params = self.sizing_params.get('risk_based', {})`
      * `risk_capital = cash * risk_params.get('risk_per_trade', 0.01)`
      * `size1 = risk_capital / risk_per_share`

2.  **`method == 'kelly_criterion'` の場合 (新規追加)**

      * `kelly_params = self.sizing_params.get('kelly_criterion', {})`
      * `f_source = kelly_params.get('f_value_source', 'adjusted')`
      * `f_value` を `f_source` に基づき取得（`fixed`, `adjusted`, `raw` の順で分岐）。
          * `adjusted` または `raw` 選択時に `self.statistics` が空の場合、`f_value = 0.0` とする。
      * `f_value` に `max_f_value_cap` を適用（`f_value = min(f_value, max_f_value_cap)`）。
      * `investment_amount = cash * f_value`
      * `size1 = investment_amount / entry_price`

3.  **共通制約 (現状維持)**

      * `size2 = self.sizing_params.get('max_investment_per_trade', 1e7) / entry_price`
      * **最終数量 = `min(size1, size2)`**

## 4\. モード別動作

### 4.1. バックテストモード (`run_backtest.py`)

1.  `config/strategy_base.yml` から `sizing_params['backtest_method']`（例: 'risk\_based'）を読み取る。
2.  `BacktestStrategy` は、`BacktestOrderManager` を初期化する際、`method='risk_based'` を渡し、`statistics=None` を渡す。
3.  `BaseOrderManager` は `self.method` に従ってサイジングを実行する。
4.  `method` に `'kelly_criterion'` を指定した場合、`self.statistics` が `None` のため、`f_value_source: 'fixed'` のみ（固定比率投資）が動作する。

### 4.2. リアルタイム取引モード (`run_realtrade.py`)

1.  `config/strategy_base.yml` から `sizing_params['realtrade_method']`（例: 'kelly\_criterion'）を読み取る。
2.  `RealtimeTrader` が `statistics_map` を構築する（3.2参照）。
3.  `RealTradeStrategy` は、`RealTradeOrderManager` を初期化する際、`method='kelly_criterion'` と、該当する `statistics` 辞書を渡す。
4.  `BaseOrderManager` は `self.method` と `self.statistics` に基づき、`adjusted` または `raw` のf値を使用してサイジングを実行する。

-----