はい、承知いたしました。  
影響を最小化するアーキテクチャ（Ver. 1.2）を反映した、詳細設計書の全文を以下に掲載します。

---

## **リアルタイム自動トレード監視ダッシュボード 詳細設計書**

| ドキュメントバージョン | 1.2 (影響最小化版) |
| :---- | :---- |
| **作成日** | 2025年8月1日 |
| **作成者** | Gemini |
| **対象ドキュメント** | 機能仕様書 (Ver. 1.1) |

### **1\. はじめに**

本書は、「機能仕様書 Ver. 1.1」で定義されたリアルタイム監視ダッシュボードを、既存の取引エンジンへの影響を最小限に抑えつつ実装するための、詳細な技術設計を定めます。

本書は、取引エンジンとダッシュボードを**プロセスレベルで完全に分離**し、両者間の情報共有を共有データベース(SQLite)で行うことを前提とします。

### **2\. アーキテクチャ詳細**

#### **2.1. プロセス分離アーキテクチャ**

取引エンジンとダッシュボードは、それぞれ独立して実行可能な2つのプロセスに分離します。

* **取引エンジン・プロセス (python \-m src.realtrade.run\_realtrade)**  
  * 従来通り、リアルタイムでの取引執行に専念します。  
  * 自身の最新状態を、共有データベース(SQLite)に定期的に書き出します。  
* **ダッシュボード・プロセス (python \-m src.dashboard.run\_dashboard)**  
  * **新規作成**するFlask Webアプリケーションです。  
  * 共有データベースを定期的にポーリングし、最新情報を取得してダッシュボード画面を構築・更新します。

#### **2.2. データ連携**

プロセス間の情報共有は、src/realtrade/state\_manager.pyが管理する**SQLiteデータベース**を仲介役として行います。これにより、新たなミドルウェアを導入することなく、プロセス間の疎結合を実現します。

コード スニペット

graph TD  
    subgraph "Process 1: 取引エンジン"  
        A\[run\_realtrade.py\] \--\>|1. 状態を書き込み| B(SQLite DB)  
    end

    subgraph "Process 2: ダッシュボード"  
        C\[run\_dashboard.py\] \--\>|2. 状態を読み込み| B  
        C \--\> D\[Web UI\]  
    end

### **3\. データベース拡張設計**

#### **3.1. src/realtrade/state\_manager.py の拡張**

既存のstate\_manager.pyに、リアルタイム状態をJSON形式で格納するキー・バリューストア形式のテーブルを新設します。

* **新テーブル定義: live\_status**  
  SQL  
  CREATE TABLE IF NOT EXISTS live\_status (  
      key TEXT PRIMARY KEY,  
      value TEXT NOT NULL,  
      updated\_at TEXT NOT NULL  
  );

* **StateManagerクラスへのメソッド追加:**  
  Python  
  \# state\_manager.py に追加  
  def update\_live\_status(self, key, data\_dict):  
      \# valueをJSON文字列に変換して保存  
      sql \= "INSERT OR REPLACE INTO live\_status (key, value, updated\_at) VALUES (?, ?, ?)"  
      try:  
          with self.lock:  
              cursor \= self.conn.cursor()  
              \# 現在時刻をISO 8601形式で記録  
              now \= datetime.now().isoformat()  
              cursor.execute(sql, (key, json.dumps(data\_dict), now))  
              self.conn.commit()  
      except (sqlite3.Error, TypeError) as e:  
          logger.error(f"ライブステータス更新エラー (key: {key}): {e}")

### **4\. 既存コンポーネントへの変更点**

#### **4.1. src/core/strategy.py の変更**

DynamicStrategyのnextメソッドの最後に、DBへ状態を書き込む処理を追加します。この処理はstate\_managerが渡された場合のみ実行され、バックテスト等には影響しません。

Python

\# strategy.py の next()メソッドの最後に追記  
def next(self):  
    \# \--- (既存の全処理) \---

    \# state\_managerがリアルタイム取引時に渡されている場合のみ実行  
    if self.p.live\_trading and hasattr(self.p, 'state\_manager') and self.p.state\_manager:  
        \# 銘柄ごとの詳細情報を更新  
        key \= f"chart\_{self.data0.\_name}"  
        status\_data \= {  
            "price": self.data.close\[0\],  
            "dt": self.data.datetime.datetime(0).isoformat(),  
            "position\_size": self.getposition().size,  
            "position\_price": self.getposition().price,  
            "sl\_price": self.sl\_price,  
            "tp\_price": self.tp\_price,  
            \# (例) RSIインジケーターの値  
            "rsi14": self.indicators.get(f"short\_rsi\_period\_14")\[0\] if f"short\_rsi\_period\_14" in self.indicators else None  
        }  
        self.p.state\_manager.update\_live\_status(key, status\_data)

        \# 全体サマリーを更新 (最初のスレッドが代表して行うなどの工夫が望ましい)  
        \# ここでは簡略化のため、各スレッドがBrokerの情報を更新する  
        summary\_key \= "summary"  
        summary\_data \= {  
            "cash": self.broker.getcash(),  
            "value": self.broker.getvalue()  
        }  
        self.p.state\_manager.update\_live\_status(summary\_key, summary\_data)

#### **4.2. src/realtrade/run\_realtrade.py の変更**

DynamicStrategyへstate\_managerのインスタンスを渡すための1行を追加します。

Python

\# run\_realtrade.py の \_create\_cerebro\_for\_symbol() 内  
def \_create\_cerebro\_for\_symbol(self, symbol):  
    \# ...  
    \# cerebro.addstrategy()の引数にstate\_managerを追加  
    cerebro.addstrategy(btrader\_strategy.DynamicStrategy,  
                        \# ... (既存の引数)  
                        state\_manager=self.state\_manager) \# \<\<\< この行を追加  
    \# ...

### **5\. ダッシュボード設計 (src/dashboard/)**

#### **5.1. run\_dashboard.py (新規作成)**

ダッシュボードの独立したエントリーポイント（起動スクリプト）です。

Python

\# src/dashboard/run\_dashboard.py  
import os  
from .app import create\_app

def main():  
    \# 共有DBのパスを指定  
    \# プロジェクトルートからの相対パスで解決  
    project\_root \= os.path.abspath(os.path.join(os.path.dirname(\_\_file\_\_), '..', '..'))  
    db\_path \= os.path.join(project\_root, "results", "realtrade", "realtrade\_state.db")

    if not os.path.exists(db\_path):  
        print(f"エラー: データベースファイルが見つかりません: {db\_path}")  
        print("先にリアルタイム取引を一度実行して、DBファイルを生成してください。")  
        return

    \# Flaskアプリを生成して実行  
    app \= create\_app(db\_path=db\_path)  
    \# 本番環境ではGunicornなどのWSGIサーバーの使用を推奨  
    app.run(host='0.0.0.0', port=5003, debug=False)

if \_\_name\_\_ \== '\_\_main\_\_':  
    main()

#### **5.2. data\_provider.py (新規作成)**

SQLiteからデータを読み出し、APIが必要とする形式に整形する責務を担います。

Python

\# src/dashboard/data\_provider.py  
import sqlite3  
import json

class DataProvider:  
    def \_\_init\_\_(self, db\_path):  
        self.db\_path \= db\_path

    def \_query\_db(self, query, params=()):  
        \# 読み取り専用で接続  
        db\_uri \= f"file:{self.db\_path}?mode=ro"  
        with sqlite3.connect(db\_uri, uri=True) as conn:  
            cursor \= conn.cursor()  
            cursor.execute(query, params)  
            return cursor.fetchall()

    def get\_status(self):  
        \# 全てのライブステータスを取得  
        rows \= self.\_query\_db("SELECT key, value FROM live\_status")  
        status \= {"summary": {}, "positions": \[\]}  
        for key, value in rows:  
            data \= json.loads(value)  
            if key \== 'summary':  
                status\['summary'\] \= data  
            elif key.startswith('chart\_'):  
                symbol \= key.split('\_', 1)\[1\]  
                if data.get('position\_size', 0) \!= 0:  
                    \# ポジションがあるものだけを一覧に追加  
                    position\_info \= {  
                        "symbol": symbol,  
                        "side": "Long" if data\['position\_size'\] \> 0 else "Short",  
                        "quantity": data\['position\_size'\],  
                        "entry\_price": data\['position\_price'\],  
                        "current\_price": data\['price'\]  
                        \# ... 他のサマリー情報を計算 ...  
                    }  
                    status\['positions'\].append(position\_info)  
        return status  
    \# ... 他のデータ取得メソッド ...

#### **5.3. app.py の改修**

Flaskアプリの生成をファクトリパターン（create\_app）に変更し、data\_providerからデータを取得するようにAPIを実装します。

Python

\# src/dashboard/app.py  
from flask import Flask, jsonify, render\_template  
from .data\_provider import DataProvider

def create\_app(db\_path):  
    app \= Flask(\_\_name\_\_)  
    \# アプリケーションコンテキストにデータプロバイダーを格納  
    app.config\['DATA\_PROVIDER'\] \= DataProvider(db\_path)

    @app.route('/live')  
    def live\_dashboard():  
        return render\_template('live\_dashboard.html') \# 新しいテンプレートを参照

    @app.route('/api/live/status')  
    def api\_live\_status():  
        provider \= app.config\['DATA\_PROVIDER'\]  
        status \= provider.get\_status()  
        return jsonify(status)

    \# ... 他のAPIエンドポイント ...  
    return app  
